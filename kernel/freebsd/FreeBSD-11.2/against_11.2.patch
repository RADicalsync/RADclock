diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/_ffcounter.h /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/_ffcounter.h
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/_ffcounter.h	2019-11-15 19:46:12.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/_ffcounter.h	2020-08-19 11:49:42.000000000 +1000
@@ -4,4 +4,4 @@
  *
- * This software was developed by Julien Ridoux at the University of Melbourne
- * under sponsorship from the FreeBSD Foundation.
+ * This software was developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.c	2020-08-19 11:49:42.000000000 +1000
@@ -9,2 +9,5 @@
  *
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
+ *
  * Redistribution and use in source and binary forms, with or without
@@ -41,2 +44,3 @@
 #include "opt_compat.h"
+#include "opt_ffclock.h"
 #include "opt_ddb.h"
@@ -60,2 +64,3 @@
 #include <sys/sockio.h>
+#include <sys/timeffc.h>
 #include <sys/ttycom.h>
@@ -112,2 +117,4 @@
 	int		bif_flags;	/* Interface flags */
+//	struct sysctl_oid *tscfgoid;	/* timestamp sysctl oid for interface */
+//	int tstype;							/* if-level timestamp interface */
 	struct bpf_if	**bif_bpf;	/* Pointer to pointer to us */
@@ -138,2 +145,3 @@
 	struct timeval32 bh_tstamp;	/* time stamp */
+	ffcounter	bh_ffcounter;	/* feed-forward counter stamp */
 	uint32_t	bh_caplen;	/* length of captured portion */
@@ -143,3 +151,3 @@
 };
-#endif
+#endif /* !BURN_BRIDGES */
 
@@ -161,3 +169,26 @@
 #define	BIOCSETFNR32	_IOW('B', 130, struct bpf_program32)
-#endif
+#endif /* COMPAT_FREEBSD32 */
+
+/*
+ * Safety belt to ensure ABI of structs bpf_hdr32, bpf_hdr and bpf_xhdr are
+ * preserved for use with FFCLOCK, which changes the stamp field in the
+ * structs to allow storing a regular time stamp or ffcounter stamp.
+ */
+CTASSERT(sizeof(struct bpf_ts) >= sizeof(ffcounter) &&
+    sizeof(struct bintime) >= sizeof(ffcounter));
+
+//static const char *bpfiftstypes[] = {
+//	"default",
+//#define	BPF_TSTAMP_DEFAULT	0
+//	"none",
+//#define	BPF_TSTAMP_NONE		1
+//	"fast",
+//#define	BPF_TSTAMP_FAST		2
+//	"normal",
+//#define	BPF_TSTAMP_NORMAL	3
+//	"external"
+//#define	BPF_TSTAMP_EXTERNAL	4
+//};
+//#define	NUM_BPFIFTSTYPES	(sizeof(bpfiftstypes) / sizeof(*bpfiftstypes))
+
 
@@ -188,3 +219,7 @@
 		    void (*)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+#ifdef FFCLOCK
+		    struct bintime *, ffcounter *);
+#else
 		    struct bintime *);
+#endif
 static void	reset_d(struct bpf_d *);
@@ -197,2 +232,3 @@
 static int	bpf_stats_sysctl(SYSCTL_HANDLER_ARGS);
+//static int	bpf_tscfg_sysctl_handler(SYSCTL_HANDLER_ARGS);
 
@@ -207,2 +243,8 @@
     bpf_stats_sysctl, "bpf statistics portal");
+//static SYSCTL_NODE(_net_bpf, OID_AUTO, tscfg, CTLFLAG_RW, NULL,
+//    "Per-interface timestamp configuration");
+//static int bpf_default_tstype = BPF_TSTAMP_NORMAL;
+//SYSCTL_PROC(_net_bpf_tscfg, OID_AUTO, default,
+//    CTLTYPE_STRING | CTLFLAG_RW, NULL, 0, bpf_tscfg_sysctl_handler, "A",
+//    "Per-interface system wide default timestamp configuration");
 
@@ -1683,3 +1725,2 @@
 			u_int	func;
-
 			func = *(u_int *)addr;
@@ -2078,44 +2119,2 @@
 
-#define	BPF_TSTAMP_NONE		0
-#define	BPF_TSTAMP_FAST		1
-#define	BPF_TSTAMP_NORMAL	2
-#define	BPF_TSTAMP_EXTERN	3
-
-static int
-bpf_ts_quality(int tstype)
-{
-
-	if (tstype == BPF_T_NONE)
-		return (BPF_TSTAMP_NONE);
-	if ((tstype & BPF_T_FAST) != 0)
-		return (BPF_TSTAMP_FAST);
-
-	return (BPF_TSTAMP_NORMAL);
-}
-
-static int
-bpf_gettime(struct bintime *bt, int tstype, struct mbuf *m)
-{
-	struct m_tag *tag;
-	int quality;
-
-	quality = bpf_ts_quality(tstype);
-	if (quality == BPF_TSTAMP_NONE)
-		return (quality);
-
-	if (m != NULL) {
-		tag = m_tag_locate(m, MTAG_BPF, MTAG_BPF_TIMESTAMP, NULL);
-		if (tag != NULL) {
-			*bt = *(struct bintime *)(tag + 1);
-			return (BPF_TSTAMP_EXTERN);
-		}
-	}
-	if (quality == BPF_TSTAMP_NORMAL)
-		binuptime(bt);
-	else
-		getbinuptime(bt);
-
-	return (quality);
-}
-
 /*
@@ -2130,3 +2129,5 @@
 	struct bintime bt;
+	struct sysclock_snap cs;
 	struct bpf_d *d;
+	u_int slen;
 #ifdef BPF_JITTER
@@ -2134,7 +2135,6 @@
 #endif
-	u_int slen;
-	int gottime;
-
-	gottime = BPF_TSTAMP_NONE;
 
+	/* Obtain state data and tc counter timestamp for both FF and FB clocks */
+	sysclock_getsnapshot(&cs, 0);
+	
 	BPFIF_RLOCK(bp);
@@ -2144,6 +2144,4 @@
 		 * We are not using any locks for d here because:
-		 * 1) any filter change is protected by interface
-		 * write lock
-		 * 2) destroying/detaching d is protected by interface
-		 * write lock, too
+		 * 1) any filter change is protected by interface write lock
+		 * 2) destroying/detaching d is protected by interface write lock, too
 		 */
@@ -2172,4 +2170,20 @@
 			d->bd_fcount++;
-			if (gottime < bpf_ts_quality(d->bd_tstamp))
-				gottime = bpf_gettime(&bt, d->bd_tstamp, NULL);
+			
+			/* Obtain ts if requested, no external ts in bpf_tap case */
+			if ( BPF_T_FORMAT(d->bd_tstamp)!=BPF_T_NONE ) {
+				if ( (sysclock_active==SYSCLOCK_FBCK
+						&& BPF_T_CLOCK(d->bd_tstamp)==BPF_T_SYSCLOCK)
+						|| BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FBCLOCK )
+					sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FBCK,
+						d->bd_tstamp & BPF_T_FAST,
+						d->bd_tstamp & BPF_T_MONOTONIC, 0, 0);
+				else
+					sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FFWD,
+						d->bd_tstamp & BPF_T_FAST,
+						d->bd_tstamp & BPF_T_MONOTONIC,
+						BPF_T_CLOCK(d->bd_tstamp)< BPF_T_FFNATIVECLOCK,
+						BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FFDIFFCLOCK );
+			}	else
+				bzero(&bt, sizeof(bt));
+
 #ifdef MAC
@@ -2177,4 +2191,16 @@
 #endif
-				catchpacket(d, pkt, pktlen, slen,
-				    bpf_append_bytes, &bt);
+#ifdef FFCLOCK
+			{
+				printf(" ** in bpf_tap **\n");
+				ffcounter ffcount = 0;
+				if (BPF_T_FFRAW(d->bd_tstamp) == BPF_T_FFC)
+					catchpacket(d, pkt, pktlen, slen,
+						bpf_append_mbuf, &bt, &cs.ffcount);
+				else
+					catchpacket(d, pkt, pktlen, slen,
+						bpf_append_mbuf, &bt, &ffcount);
+			}
+#else
+				catchpacket(d, pkt, pktlen, slen, bpf_append_bytes, &bt);
+#endif
 			BPFD_UNLOCK(d);
@@ -2197,3 +2223,6 @@
 	struct bintime bt;
+	struct sysclock_snap cs;
 	struct bpf_d *d;
+	struct m_tag *tag;
+	u_int pktlen, slen;
 #ifdef BPF_JITTER
@@ -2201,4 +2230,2 @@
 #endif
-	u_int pktlen, slen;
-	int gottime;
 
@@ -2210,4 +2237,6 @@
 
+	/* Obtain state data for both FF and FB clocks */
+	sysclock_getsnapshot(&cs, 0);
+
 	pktlen = m_length(m, NULL);
-	gottime = BPF_TSTAMP_NONE;
 
@@ -2229,6 +2258,26 @@
 			BPFD_LOCK(d);
-
+			
 			d->bd_fcount++;
-			if (gottime < bpf_ts_quality(d->bd_tstamp))
-				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+
+			/* Obtain ts if requested, and not already supplied externally */
+			if ( BPF_T_FORMAT(d->bd_tstamp)!=BPF_T_NONE ) {
+				tag = m_tag_locate(m, MTAG_BPF, MTAG_BPF_TIMESTAMP, NULL);
+				if (tag != NULL)	// if external ts available, use it
+					bt = *(struct bintime *)(tag + 1);
+				else
+					if ( (sysclock_active==SYSCLOCK_FBCK
+							&& BPF_T_CLOCK(d->bd_tstamp)==BPF_T_SYSCLOCK)
+							|| BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FBCLOCK )
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FBCK,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC, 0, 0);
+					else
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FFWD,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC,
+							BPF_T_CLOCK(d->bd_tstamp)< BPF_T_FFNATIVECLOCK,
+							BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FFDIFFCLOCK );
+			} else
+				bzero(&bt, sizeof(bt));
+				
 #ifdef MAC
@@ -2236,4 +2285,16 @@
 #endif
-				catchpacket(d, (u_char *)m, pktlen, slen,
-				    bpf_append_mbuf, &bt);
+#ifdef FFCLOCK
+				{
+					//printf(" ** in bpf_mtap **\n");
+					ffcounter ffcount = 0;
+					if (BPF_T_FFRAW(d->bd_tstamp) == BPF_T_FFC)
+						catchpacket(d, (u_char *)m, pktlen, slen,
+							bpf_append_mbuf, &bt, &cs.ffcount);
+					else
+						catchpacket(d, (u_char *)m, pktlen, slen,
+							bpf_append_mbuf, &bt, &ffcount);
+				}
+#else
+				catchpacket(d, (u_char *)m, pktlen, slen, bpf_append_mbuf, &bt);
+#endif
 			BPFD_UNLOCK(d);
@@ -2252,6 +2313,7 @@
 	struct bintime bt;
+	struct sysclock_snap cs;
 	struct mbuf mb;
 	struct bpf_d *d;
+	struct m_tag *tag;
 	u_int pktlen, slen;
-	int gottime;
 
@@ -2263,2 +2325,5 @@
 
+	/* Obtain state data for both FF and FB clocks */
+	sysclock_getsnapshot(&cs, 0);
+	
 	pktlen = m_length(m, NULL);
@@ -2274,4 +2339,2 @@
 
-	gottime = BPF_TSTAMP_NONE;
-
 	BPFIF_RLOCK(bp);
@@ -2287,4 +2350,23 @@
 			d->bd_fcount++;
-			if (gottime < bpf_ts_quality(d->bd_tstamp))
-				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+
+			/* Obtain ts if requested, and not already supplied externally */
+			if ( BPF_T_FORMAT(d->bd_tstamp)!=BPF_T_NONE ) {
+				tag = m_tag_locate(m, MTAG_BPF, MTAG_BPF_TIMESTAMP, NULL);
+				if (tag != NULL)	// if external ts available, use it
+					bt = *(struct bintime *)(tag + 1);
+				else
+					if ( (sysclock_active==SYSCLOCK_FBCK
+							&& BPF_T_CLOCK(d->bd_tstamp)==BPF_T_SYSCLOCK)
+							|| BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FBCLOCK )
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FBCK,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC, 0, 0);
+					else
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FFWD,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC,
+							BPF_T_CLOCK(d->bd_tstamp)< BPF_T_FFNATIVECLOCK,
+							BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FFDIFFCLOCK );
+			} else
+				bzero(&bt, sizeof(bt));
 #ifdef MAC
@@ -2292,4 +2374,16 @@
 #endif
-				catchpacket(d, (u_char *)&mb, pktlen, slen,
-				    bpf_append_mbuf, &bt);
+#ifdef FFCLOCK
+				{
+					printf(" ** in bpf_tap2 **\n");
+					ffcounter ffcount = 0;
+					if (BPF_T_FFRAW(d->bd_tstamp) == BPF_T_FFC)
+						catchpacket(d, (u_char *)&mb, pktlen, slen,
+							bpf_append_mbuf, &bt, &cs.ffcount);
+					else
+						catchpacket(d, (u_char *)&mb, pktlen, slen,
+							bpf_append_mbuf, &bt, &ffcount);
+				}
+#else
+				catchpacket(d, (u_char *)&mb, pktlen, slen, bpf_append_mbuf, &bt);
+#endif
 			BPFD_UNLOCK(d);
@@ -2302,7 +2396,2 @@
 
-#undef	BPF_TSTAMP_NONE
-#undef	BPF_TSTAMP_FAST
-#undef	BPF_TSTAMP_NORMAL
-#undef	BPF_TSTAMP_EXTERN
-
 static int
@@ -2338,3 +2427,2 @@
 {
-	struct bintime bt2, boottimebin;
 	struct timeval tsm;
@@ -2342,8 +2430,2 @@
 
-	if ((tstype & BPF_T_MONOTONIC) == 0) {
-		bt2 = *bt;
-		getboottimebin(&boottimebin);
-		bintime_add(&bt2, &boottimebin);
-		bt = &bt2;
-	}
 	switch (BPF_T_FORMAT(tstype)) {
@@ -2376,3 +2458,7 @@
     void (*cpfn)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+#ifdef FFCLOCK
+    struct bintime *bt, ffcounter *ffcount)
+#else
     struct bintime *bt)
+#endif
 {
@@ -2431,2 +2517,3 @@
 		curlen = BPF_WORDALIGN(d->bd_slen);
+
 	if (curlen + totlen > d->bd_bufsize || !bpf_canwritebuf(d)) {
@@ -2435,4 +2522,3 @@
 			 * There's no room in the store buffer, and no
-			 * prospect of room, so drop the packet.  Notify the
-			 * buffer model.
+			 * prospect of room, so drop the packet.  Notify the buffer model.
 			 */
@@ -2453,7 +2539,8 @@
 		do_wakeup = 1;
+
 	caplen = totlen - hdrlen;
 	tstype = d->bd_tstamp;
-	do_timestamp = tstype != BPF_T_NONE;
+	do_timestamp = BPF_T_FORMAT(tstype) != BPF_T_NONE;
 #ifndef BURN_BRIDGES
-	if (tstype == BPF_T_NONE || BPF_T_FORMAT(tstype) == BPF_T_MICROTIME) {
+	if (BPF_T_FORMAT(tstype)==BPF_T_NONE || BPF_T_FORMAT(tstype)==BPF_T_MICROTIME) {
 		struct bpf_ts ts;
@@ -2468,2 +2555,5 @@
 			}
+#ifdef FFCLOCK
+			hdr32_old.bh_ffcounter = *ffcount;
+#endif
 			hdr32_old.bh_datalen = pktlen;
@@ -2471,4 +2561,3 @@
 			hdr32_old.bh_caplen = caplen;
-			bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr32_old,
-			    sizeof(hdr32_old));
+			bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr32_old, sizeof(hdr32_old));
 			goto copy;
@@ -2481,2 +2570,5 @@
 		}
+#ifdef FFCLOCK
+		hdr_old.bh_ffcounter = *ffcount;
+#endif
 		hdr_old.bh_datalen = pktlen;
@@ -2492,3 +2584,3 @@
 	 * Append the bpf header.  Note we append the actual header size, but
-	 * move forward the length of the header plus padding.
+	 * later only move forward by hdrlen (bpf-aligned trailing padding)
 	 */
@@ -2497,2 +2589,5 @@
 		bpf_bintime2ts(bt, &hdr.bh_tstamp, tstype);
+#ifdef FFCLOCK
+	hdr.bh_ffcounter = *ffcount;
+#endif
 	hdr.bh_datalen = pktlen;
@@ -2541,2 +2636,60 @@
 
+///*
+// * Show or change the per bpf_if or system wide default timestamp configuration.
+// */
+//static int
+//bpf_tscfg_sysctl_handler(SYSCTL_HANDLER_ARGS)
+//{
+//	char tstype_name[16];
+//	struct bpf_if *bp;
+//	int error, tstype;
+//
+//	bp = (struct bpf_if *)arg1;
+//
+//	if (req->newptr == NULL) {
+//		/*
+//		 * Return the name of the BPF interface's timestamp setting, or
+//		 * the system wide default if bp is NULL.
+//		 */
+//		strlcpy(tstype_name,
+//		    bpfiftstypes[bp ? bp->tstype : bpf_default_tstype],
+//		    sizeof(tstype_name));
+//		error = sysctl_handle_string(oidp, tstype_name,
+//		    sizeof(tstype_name), req);
+//	} else {
+//		/*
+//		 * Change the timestamp configuration for this BPF interface or
+//		 * the system wide default setting.
+//		 */
+//		error = EINVAL;
+//		for (tstype = 0; tstype < NUM_BPFIFTSTYPES; tstype++) {
+//			if (strncmp((char *)req->newptr, bpfiftstypes[tstype],
+//			    strlen(bpfiftstypes[tstype])) == 0) {
+//				/* User specified type found in bpfiftstypes. */
+//				if (strcmp(oidp->oid_name, "default") == 0) {
+//					/*
+//					 * Don't allow BPF_TSTAMP_DEFAULT to be
+//					 * assigned to the
+//					 * "net.bpf.tscfg.default" OID.
+//					 */
+//					if (tstype != BPF_TSTAMP_DEFAULT) {
+//						bpf_default_tstype = tstype;
+//						error = 0;
+//					}
+//				} else {
+//					/*
+//					 * Valid tstype for
+//					 * "net.bpf.tscfg.<iface>" OID.
+//					 */
+//					bp->tstype = tstype;
+//					error = 0;
+//				}
+//				break;
+//			}
+//		}
+//	}
+//
+//	return (error);
+//}
+
 /*
@@ -2567,2 +2720,13 @@
 
+//	bp->tscfgoid = SYSCTL_ADD_PROC(NULL,
+//	    SYSCTL_STATIC_CHILDREN(_net_bpf_tscfg), OID_AUTO, ifp->if_xname,
+//	    CTLTYPE_STRING | CTLFLAG_RW, bp, sizeof(bp),
+//	    bpf_tscfg_sysctl_handler, "A",
+//	    "Interface BPF timestamp configuration");
+//	if (bp->tscfgoid == NULL) {
+//		free(bp, M_BPF);
+//		panic("bpfattach tscfgoid");
+//	}
+//
+//	bp->tstype = BPF_TSTAMP_DEFAULT;
 	LIST_INIT(&bp->bif_dlist);
@@ -2707,3 +2871,3 @@
 		LIST_REMOVE(bp, bif_next);
-
+        
 		rw_destroy(&bp->bif_lock);
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.h /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.h
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.h	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.h	2020-08-19 11:49:42.000000000 +1000
@@ -9,2 +9,5 @@
  *
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
+ *
  * Redistribution and use in source and binary forms, with or without
@@ -42,2 +45,4 @@
 
+#include <sys/_ffcounter.h>
+
 /* BSD style release date */
@@ -161,28 +166,47 @@
 
-/* Time stamping functions */
-#define	BPF_T_MICROTIME		0x0000
+/* Time stamping flags */
+// FORMAT flags 	[ mutually exclusive, not to be ORed ]
+#define	BPF_T_MICROTIME	0x0000
 #define	BPF_T_NANOTIME		0x0001
 #define	BPF_T_BINTIME		0x0002
-#define	BPF_T_NONE		0x0003
+#define	BPF_T_NONE			0x0003	// relates to ts only, FFRAW independent
 #define	BPF_T_FORMAT_MASK	0x0003
-#define	BPF_T_NORMAL		0x0000
-#define	BPF_T_FAST		0x0100
-#define	BPF_T_MONOTONIC		0x0200
-#define	BPF_T_MONOTONIC_FAST	(BPF_T_FAST | BPF_T_MONOTONIC)
-#define	BPF_T_FLAG_MASK		0x0300
-#define	BPF_T_FORMAT(t)		((t) & BPF_T_FORMAT_MASK)
-#define	BPF_T_FLAG(t)		((t) & BPF_T_FLAG_MASK)
-#define	BPF_T_VALID(t)						\
-    ((t) == BPF_T_NONE || (BPF_T_FORMAT(t) != BPF_T_NONE &&	\
-    ((t) & ~(BPF_T_FORMAT_MASK | BPF_T_FLAG_MASK)) == 0))
-
-#define	BPF_T_MICROTIME_FAST		(BPF_T_MICROTIME | BPF_T_FAST)
-#define	BPF_T_NANOTIME_FAST		(BPF_T_NANOTIME | BPF_T_FAST)
-#define	BPF_T_BINTIME_FAST		(BPF_T_BINTIME | BPF_T_FAST)
-#define	BPF_T_MICROTIME_MONOTONIC	(BPF_T_MICROTIME | BPF_T_MONOTONIC)
-#define	BPF_T_NANOTIME_MONOTONIC	(BPF_T_NANOTIME | BPF_T_MONOTONIC)
-#define	BPF_T_BINTIME_MONOTONIC		(BPF_T_BINTIME | BPF_T_MONOTONIC)
-#define	BPF_T_MICROTIME_MONOTONIC_FAST	(BPF_T_MICROTIME | BPF_T_MONOTONIC_FAST)
-#define	BPF_T_NANOTIME_MONOTONIC_FAST	(BPF_T_NANOTIME | BPF_T_MONOTONIC_FAST)
-#define	BPF_T_BINTIME_MONOTONIC_FAST	(BPF_T_BINTIME | BPF_T_MONOTONIC_FAST)
+// FFRAW flag
+#define	BPF_T_NOFFC			0x0000   // no FFcount
+#define	BPF_T_FFC			0x0010   // want FFcount
+#define	BPF_T_FFRAW_MASK	0x0010
+// FLAVOR flags   [ can view bits as ORable flags ]
+#define	BPF_T_NORMAL		0x0000	// UTC, !FAST
+#define	BPF_T_FAST			0x0100   // UTC,  FAST
+#define	BPF_T_MONOTONIC	0x0200	// UPTIME, !FAST
+#define	BPF_T_MONOTONIC_FAST	0x0300// UPTIME,  FAST
+#define	BPF_T_FLAVOR_MASK	0x0300
+// CLOCK flags   [ mutually exclusive, not to be ORed ]
+#define	BPF_T_SYSCLOCK		0x0000	// read current sysclock
+#define	BPF_T_FBCLOCK		0x1000   // read FB
+#define	BPF_T_FFCLOCK		0x2000   // read mono FF (standard reads are mono)
+#define	BPF_T_FFNATIVECLOCK	0x3000	// read native FF
+#define	BPF_T_FFDIFFCLOCK	0x4000	// read FF difference clock
+#define	BPF_T_CLOCK_MASK	0x7000
+
+// Extract FORMAT, FFRAW, FLAVOR, CLOCK  bits
+#define	BPF_T_FORMAT(t)	((t) & BPF_T_FORMAT_MASK)
+#define	BPF_T_FFRAW(t)		((t) & BPF_T_FFRAW_MASK)
+#define	BPF_T_FLAVOR(t)	((t) & BPF_T_FLAVOR_MASK)
+#define	BPF_T_CLOCK(t)		((t) & BPF_T_CLOCK_MASK)
+
+// Used to vet descriptor passed to BPF via BIOCSTSTAMP ioctl
+// In KV3, all components are independent, and either always meaningful, or
+// not acted on if not meaningful (eg if !FFCLOCK, or value of CLOCK if requesting
+// BPF_T_NONE   Hence checks reduce to ensuring no bits in undefined positions,
+// and not ask for a FF clock that doesnt exist.
+#ifdef FFCLOCK
+#define	BPF_T_VALID(t)	( ((t) & ~(BPF_T_FORMAT_MASK | BPF_T_FFRAW_MASK | \
+											  BPF_T_FLAVOR_MASK | BPF_T_CLOCK_MASK)) == 0 \
+									&& BPF_T_CLOCK(t)<=BPF_T_FFDIFFCLOCK )
+#else
+#define	BPF_T_VALID(t)	( ((t) & ~(BPF_T_FORMAT_MASK | BPF_T_FFRAW_MASK | \
+											  BPF_T_FLAVOR_MASK | BPF_T_CLOCK_MASK)) == 0 \
+									&& BPF_T_CLOCK(t)<=BPF_T_FBCLOCK )
+#endif
 
@@ -197,2 +221,3 @@
 	struct bpf_ts	bh_tstamp;	/* time stamp */
+	ffcounter	bh_ffcounter;	/* feed-forward counter stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
@@ -205,2 +230,3 @@
 	struct timeval	bh_tstamp;	/* time stamp */
+	ffcounter	bh_ffcounter;	/* feed-forward counter stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
@@ -215,2 +241,9 @@
 
+#ifdef FFCLOCK
+/*
+ * Feed-forward counter accessor.
+ */
+#define	BP
+#endif
+
 /*
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/ffclock.2 /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/ffclock.2
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/ffclock.2	1970-01-01 10:00:00.000000000 +1000
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/ffclock.2	2020-08-19 11:49:42.000000000 +1000
@@ -0,0 +1,177 @@
+.\" Copyright (c) 2011 The University of Melbourne
+.\" All rights reserved.
+.\"
+.\" This documentation was written by Julien Ridoux at the University of
+.\" Melbourne under sponsorship from the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd November 21, 2011
+.Dt FFCLOCK 2
+.Os
+.Sh NAME
+.Nm ffclock_getcounter ,
+.Nm ffclock_getestimate ,
+.Nm ffclock_setestimate
+.Nd Retrieve feed-forward counter, get and set feed-forward clock estimates.
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In sys/timeffc.h
+.Ft int
+.Fn ffclock_getcounter "ffcounter *ffcount"
+.Ft int
+.Fn ffclock_getestimate "struct ffclock_estimate *cest"
+.Ft int
+.Fn ffclock_setestimate "struct ffclock_estimate *cest"
+.Sh DESCRIPTION
+The ffclock is an alternative method to synchronise the system clock.
+The ffclock implements a feed-forward paradigm and decouples the timestamping
+and timekeeping kernel functions.
+This ensures that past clock errors do not affect current timekeeping, an
+approach radically different from the feedback alternative implemented by the
+ntpd daemon when adjusting the system clock.
+The feed-forward approach has demonstrated better performance and higher
+robustness than a feedback approach when synchronising over the network.
+.Pp
+In the feed-forward context, a
+.Em timestamp
+is a cumulative value of the ticks of the timecounter, which can be converted
+into seconds by using the feed-forward
+.Em clock estimates.
+.Pp
+The
+.Fn ffclock_getcounter
+system call allows the calling process to retrieve the current value of the
+feed-forward counter maintained by the kernel.
+.Pp
+The
+.Fn ffclock_getestimate
+and
+.Fn ffclock_setestimate
+system calls allow the caller to get and set the kernel's feed-forward clock
+parameter estimates respectively.
+The
+.Fn ffclock_setestimate
+system call should be invoked by a single instance of a feed-forward
+synchronisation daemon.
+The
+.Fn ffclock_getestimate
+system call can be called by any process to retrieve the feed-forward clock
+estimates.
+.Pp
+The feed-forward approach does not require that the clock estimates be retrieved
+every time a timestamp is to be converted into seconds.
+The number of system calls can therefore be greatly reduced if the calling
+process retrieves the clock estimates from the clock synchronisation daemon
+instead.
+The
+.Fn ffclock_getestimate
+must be used when the feed-forward synchronisation daemon is not running
+.Po see
+.Sx USAGE
+below
+.Pc .
+.Pp
+The clock parameter estimates structure pointed to by
+.Fa cest
+is defined in
+.In sys/timeffc.h
+as:
+.Bd -literal
+struct ffclock_estimate {
+	struct bintime update_time;    /* Time of last estimates update. */
+	ffcounter      update_ffcount; /* Counter value at last update. */
+	ffcounter      leapsec_next;   /* Counter value of next leap second. */
+	uint64_t       period;         /* Estimate of counter period. */
+	uint32_t       errb_abs;       /* Bound on absolute clock error [ns]. */
+	uint32_t       errb_rate;      /* Bound on counter rate error [ps/s]. */
+	uint32_t       status;         /* Clock status. */
+	int16_t        leapsec_total;  /* All leap seconds seen so far. */
+	int8_t         leapsec;        /* Next leap second (in {-1,0,1}). */
+};
+.Ed
+.Pp
+Only the super-user may set the feed-forward clock estimates.
+.Sh RETURN VALUES
+.Rv -std
+.Sh ERRORS
+The following error codes may be set in
+.Va errno :
+.Bl -tag -width Er
+.It Bq Er EFAULT
+The
+.Fa ffcount
+or
+.Fa cest
+pointer referenced invalid memory.
+.It Bq Er EPERM
+A user other than the super-user attempted to set the feed-forward clock
+parameter estimates.
+.El
+.Sh USAGE
+The feed-forward paradigm enables the definition of specialised clock functions.
+.Pp
+In its simplest form,
+.Fn ffclock_getcounter
+can be used to establish strict order between events or to measure small time
+intervals very accurately with a minimum performance cost.
+.Pp
+Different methods exist to access absolute time
+.Po or
+.Qq wall-clock time
+.Pc tracked by the ffclock.
+The simplest method uses the ffclock sysctl interface
+.Va kern.ffclock
+to make the system clock return the ffclock time.
+The
+.Xr clock_gettime 2
+system call can then be used to retrieve the current time seen by the
+feed-forward clock.
+Note that this setting affects the entire system and that a feed-forward
+synchronisation daemon should be running.
+.Pp
+A less automated method consists of retrieving the feed-forward counter
+timestamp from the kernel and using the feed-forward clock parameter estimates
+to convert the timestamp into seconds.
+The feed-forward clock parameter estimates can be retrieved from the kernel or
+from the synchronisation daemon directly (preferred).
+This method allows converting timestamps using different clock models as needed
+by the application, while collecting meaningful upper bounds on current clock
+error.
+.Sh SEE ALSO
+.Xr date 1 ,
+.Xr adjtime 2 ,
+.Xr clock_gettime 2 ,
+.Xr ctime 3
+.Sh HISTORY
+Feed-forward clock support first appeared in
+.Fx 10.0 .
+.Sh AUTHORS
+.An -nosplit
+The feed-forward clock support was written by
+.An Julien Ridoux Aq jridoux@unimelb.edu.au
+in collaboration with
+.An Darryl Veitch Aq dveitch@unimelb.edu.au
+at the University of Melbourne under sponsorship from the FreeBSD Foundation.
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/ffclock.4 /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/ffclock.4
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/ffclock.4	1970-01-01 10:00:00.000000000 +1000
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/ffclock.4	2020-08-19 11:49:42.000000000 +1000
@@ -0,0 +1,128 @@
+.\" Copyright (c) 2011 The University of Melbourne
+.\" All rights reserved.
+.\"
+.\" This documentation was written by Julien Ridoux at the University of
+.\" Melbourne under sponsorship from the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd December 1, 2011
+.Dt FFCLOCK 4
+.Os
+.Sh NAME
+.Nm FFCLOCK
+.Nd Feed-forward system clock
+.Sh SYNOPSIS
+.Cd options FFCLOCK
+.Sh DESCRIPTION
+The
+.Xr ntpd 8
+daemon has been the dominant solution for system clock synchronisation for many
+years, which has in turn influenced the design of the system clock.
+The ntpd daemon implements a feedback control algorithm which has been
+demonstrated to perform poorly in common use cases.
+.Pp
+Feed-forward clock synchronisation algorithms implemented by an appropriate
+daemon, in concert with the
+.Nm
+kernel support, have been shown to provide highly robust and accurate clock
+synchronisation.
+In addition to time keeping, the
+.Nm
+kernel mechanism provides new timestamping capabilities and the ability to
+use specialised clocks.
+Feed-forward synchronisation is also very well suited for virtualised
+environments, reducing the overhead of timekeeping in guests and ensuring
+continued smooth operation of the system clock during guest live migration.
+.Pp
+The
+.Nm
+kernel support provides feed-forward timestamping functions within the kernel
+and system calls to support feed-forward synchronisation daemons
+.Po see
+.Xr ffclock 2
+.Pc .
+.Ss Kernel Options
+The following kernel configuration options are related to
+.Nm :
+.Pp
+.Bl -tag -width ".Dv FFCLOCK" -compact
+.It Dv FFCLOCK
+Enable feed-forward clock support.
+.El
+.Ss Configuration
+When feed-forward clock support is compiled into the kernel, multiple system
+clocks become available to choose from.
+System clock configuration is possible via the
+.Va kern.sysclock
+.Xr sysctl 8
+tree which provides the following variables:
+.Bl -tag -width "    " -offset indent
+.It Va kern.sysclock.active
+Name of the current active system clock which is serving time.
+Set to one of the names in
+.Va kern.sysclock.available
+in order to change the default active system clock.
+.It Va kern.sysclock.available
+Lists the names of available system clocks
+.Po
+read only
+.Pc .
+.El
+.Pp
+Feed-forward system clock configuration is possible via the
+.Va kern.sysclock.ffclock
+sysctl tree which provides the following variables:
+.Bl -tag -width "    " -offset indent
+.It Va kern.sysclock.ffclock.version
+Feed-forward clock kernel version
+.Po
+read only
+.Pc .
+.It Va kern.sysclock.ffclock.ffcounter_bypass
+Use reliable hardware timecounter as the feed-forward counter.
+Will eventually be useful for virtualised environment like
+.Xr xen 4 ,
+but currently does nothing.
+.El
+.Sh SEE ALSO
+.Xr clock_gettime 2 ,
+.Xr ffclock 2 ,
+.Xr bpf 4 ,
+.Xr sysctl 8
+.Sh HISTORY
+Feed-forward clock support first appeared in
+.Fx 10.0 .
+.Sh AUTHORS
+.An -nosplit
+The feed-forward clock support was written by
+.An Julien Ridoux Aq jridoux@unimelb.edu.au
+in collaboration with
+.An Darryl Veitch Aq dveitch@unimelb.edu.au
+at the University of Melbourne under sponsorship from the FreeBSD Foundation.
+.Pp
+This manual page was written by
+.An Julien Ridoux Aq jridoux@unimelb.edu.au
+and
+.An Lawrence Stewart Aq lstewart@FreeBSD.org .
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/if_em.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/if_em.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/if_em.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/if_em.c	2020-08-25 16:18:11.000000000 +1000
@@ -38,2 +38,3 @@
 #include "opt_inet6.h"
+#include "opt_ffclock.h"
 
@@ -304,3 +305,7 @@
 static void	em_setup_vlan_hw_support(struct adapter *);
+#ifdef FFCLOCK
+static int	em_xmit(struct tx_ring *, struct mbuf **, struct ifnet *);
+#else
 static int	em_xmit(struct tx_ring *, struct mbuf **);
+#endif
 static int	em_dma_malloc(struct adapter *, bus_size_t,
@@ -485,2 +490,4 @@
 
+	printf("DV: enter em_probe: \n");
+
 	INIT_DEBUGOUT("em_probe: begin");
@@ -508,2 +515,3 @@
 				em_driver_version);
+			printf("DV: found %s\n", adapter_name);
 			device_set_desc_copy(dev, adapter_name);
@@ -514,2 +522,3 @@
 
+	printf("DV: exit em_probe with %d \n",ENXIO);
 	return (ENXIO);
@@ -1004,3 +1013,11 @@
 		 */
+#ifdef FFCLOCK
+		static u_int ccc = 0;
+		if ( ccc<2 )
+			printf("DV: %u\t in  em_start_locked FF\n", ccc++);
+		/* ETHER_BPF_MTAP called at end of em_xmit, but not if return an error */
+		if (em_xmit(txr, &m_head, ifp)) {
+#else
 		if (em_xmit(txr, &m_head)) {
+#endif
 			if (m_head == NULL)
@@ -1016,4 +1033,5 @@
 		/* Send a copy of the frame to the BPF listener */
-		ETHER_BPF_MTAP(ifp, m_head);
-
+#ifndef FFCLOCK
+		ETHER_BPF_MTAP(ifp, m_head);	// now called at end of em_xmit
+#endif
 	}
@@ -1091,3 +1109,11 @@
 	while ((next = drbr_peek(ifp, txr->br)) != NULL) {
+#ifdef FFCLOCK
+		static u_int ccc = 0;
+		if ( ccc<2 )
+			printf("DV: %u\t in  em_mq_start_locked FF\n", ccc++);
+		/* ETHER_BPF_MTAP called at end of em_exit, but not if return an error */
+		if ((err = em_xmit(txr, &next, ifp)) != 0) {
+#else
 		if ((err = em_xmit(txr, &next)) != 0) {
+#endif
 			if (next == NULL) {
@@ -1110,3 +1136,5 @@
 			if_inc_counter(ifp, IFCOUNTER_OMCASTS, 1);
-		ETHER_BPF_MTAP(ifp, next);
+#ifndef FFCLOCK
+		ETHER_BPF_MTAP(ifp, next);	// now called at end of em_xmit
+#endif
 		if ((if_getdrvflags(ifp) & IFF_DRV_RUNNING) == 0)
@@ -1908,5 +1936,8 @@
  **********************************************************************/
-
 static int
+#ifdef FFCLOCK
+em_xmit(struct tx_ring *txr, struct mbuf **m_headp, struct ifnet *ifp)
+#else
 em_xmit(struct tx_ring *txr, struct mbuf **m_headp)
+#endif
 {
@@ -2210,2 +2241,8 @@
 
+#ifdef FFCLOCK
+	static u_int cccc = 0;
+	if ( cccc<2 )
+		printf("DV: %u\t in em_xmit FF\n", cccc++);
+	ETHER_BPF_MTAP(ifp, m_head);	// Move here to ensure causal read, can't fail
+#endif
 	/*
@@ -4637,3 +4674,7 @@
 	 */
+#ifndef FFCLOCK
 	E1000_WRITE_REG(hw, E1000_ITR, DEFAULT_ITR);
+#else
+	E1000_WRITE_REG(hw, E1000_ITR, 0);	// disable all interrupt throttling
+#endif
 
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/if_igb.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/if_igb.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/if_igb.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/if_igb.c	2020-08-25 16:24:46.000000000 +1000
@@ -38,2 +38,3 @@
 #include "opt_rss.h"
+#include "opt_ffclock.h"
 
@@ -191,4 +192,7 @@
 static void	igb_setup_vlan_hw_support(struct adapter *);
-
+#ifdef FFCLOCK
+static int	igb_xmit(struct tx_ring *, struct mbuf **, struct ifnet *);
+#else
 static int	igb_xmit(struct tx_ring *, struct mbuf **);
+#endif
 static int	igb_dma_malloc(struct adapter *, bus_size_t,
@@ -854,3 +858,11 @@
 		 */
+#ifdef FFCLOCK
+		static u_int ccc = 0;
+		if ( ccc<2 )
+			printf("DV: %u\t in  igb_start_locked FF\n", ccc++);
+		/* ETHER_BPF_MTAP called at end of igb_xmit, but not if return an error */
+		if (igb_xmit(txr, &m_head, ifp)) {
+#else
 		if (igb_xmit(txr, &m_head)) {
+#endif
 			if (m_head != NULL)
@@ -863,4 +875,5 @@
 		/* Send a copy of the frame to the BPF listener */
+#ifndef FFCLOCK
 		ETHER_BPF_MTAP(ifp, m_head);
-
+#endif
 		/* Set watchdog on */
@@ -961,3 +974,11 @@
 	while ((next = drbr_peek(ifp, txr->br)) != NULL) {
+#ifdef FFCLOCK
+		static u_int ccc = 0;
+		if ( ccc<2 )
+			printf("DV: %u\t in  igb_mq_start_locked FF\n", ccc++);
+		/* ETHER_BPF_MTAP called at end of igb_exit, but not if return an error */
+		if ((err = igb_xmit(txr, &next, ifp)) != 0) {
+#else
 		if ((err = igb_xmit(txr, &next)) != 0) {
+#endif
 			if (next == NULL) {
@@ -979,3 +1000,5 @@
 			if_inc_counter(ifp, IFCOUNTER_OMCASTS, 1);
+#ifndef FFCLOCK
 		ETHER_BPF_MTAP(ifp, next);
+#endif
 		if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0)
@@ -1821,3 +1844,7 @@
 static int
+#ifdef FFCLOCK
+igb_xmit(struct tx_ring *txr, struct mbuf **m_headp, struct ifnet *ifp)
+#else
 igb_xmit(struct tx_ring *txr, struct mbuf **m_headp)
+#endif
 {
@@ -1945,8 +1972,15 @@
 
-        /* Set the EOP descriptor that will be marked done */
-        txbuf = &txr->tx_buffers[first];
+	/* Set the EOP descriptor that will be marked done */
+	txbuf = &txr->tx_buffers[first];
 	txbuf->eop = txd;
 
-        bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
+	bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
             BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+            
+#ifdef FFCLOCK
+	static u_int cccc = 0;
+	if ( cccc<2 )
+		printf("DV: %u\t in em_xmit FF\n", cccc++);
+	ETHER_BPF_MTAP(ifp, m_head);	// Move here to ensure causal read, can't fail
+#endif
 	/*
@@ -1960,2 +1994,3 @@
 }
+
 static void
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_ffclock.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_ffclock.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_ffclock.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_ffclock.c	2020-08-19 11:49:42.000000000 +1000
@@ -4,4 +4,4 @@
  *
- * This software was developed by Julien Ridoux at the University of Melbourne
- * under sponsorship from the FreeBSD Foundation.
+ * This software was developed by Julien Ridoux and Darryl Veitch at the 
+ * University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -30,3 +30,3 @@
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: releng/11.2/sys/kern/kern_ffclock.c 298310 2016-04-19 23:48:27Z pfg $");
+__FBSDID("$FreeBSD$");
 
@@ -92,3 +92,3 @@
 	 * Leap second adjustment. Total as seen by synchronisation algorithm
-	 * since it started. cest.leapsec_next is the ffcounter prediction of
+	 * since it started. cest.leapsec_expected is the ffcounter prediction of
 	 * when the next leapsecond occurs.
@@ -96,5 +96,5 @@
 	if ((flags & FFCLOCK_LEAPSEC) == FFCLOCK_LEAPSEC) {
-		bt->sec -= cest.leapsec_total;
-		if (ffc > cest.leapsec_next)
-			bt->sec -= cest.leapsec;
+		bt->sec -= cest.leapsec_total;	// subtracting means including leaps
+		if (cest.leapsec_expected != 0 && ffc > cest.leapsec_expected)
+			bt->sec -= cest.leapsec_next;
 	}
@@ -110,8 +110,4 @@
 		ffclock_convert_diff(ffdelta_error, error_bound);
-		/* 18446744073709 = int(2^64/1e12), err_bound_rate in [ps/s] */
-		bintime_mul(error_bound, cest.errb_rate *
-		    (uint64_t)18446744073709LL);
-		/* 18446744073 = int(2^64 / 1e9), since err_abs in [ns] */
-		bintime_addx(error_bound, cest.errb_abs *
-		    (uint64_t)18446744073LL);
+		bintime_mul(error_bound, cest.errb_rate * PS_IN_BINFRAC);	// errb_rate ps/s
+		bintime_addx(error_bound, cest.errb_abs * NS_IN_BINFRAC);	// errb_abs [ns]
 	}
@@ -144,4 +140,3 @@
 		ffclock_convert_diff(ffdelta, error_bound);
-		/* 18446744073709 = int(2^64/1e12), err_bound_rate in [ps/s] */
-		bintime_mul(error_bound, err_rate * (uint64_t)18446744073709LL);
+		bintime_mul(error_bound, err_rate * PS_IN_BINFRAC);	// err_rate in [ps/s]
 	}
@@ -164,3 +159,3 @@
 
-static int ffclock_version = 2;
+static int ffclock_version = 3;
 SYSCTL_INT(_kern_sysclock_ffclock, OID_AUTO, version, CTLFLAG_RD,
@@ -206,3 +201,6 @@
 	int error;
-	int clk;
+	int clk=0;
+	struct bintime bt;
+	ffcounter ffcount;
+	static int ccc = 0;
 
@@ -211,2 +209,6 @@
 	error = sysctl_handle_string(oidp, newclock, sizeof(newclock), req);
+	
+	ffclock_last_tick(&ffcount, &bt, 0);
+	printf(" %d\t Callback sys_active start  %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   	ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
 
@@ -214,9 +216,11 @@
 	if (error != 0 || req->newptr == NULL)
-		goto done;
+		return (error);
 
-	/* Change the active sysclock to the user specified one: */
+	/* Change the active sysclock to the user specified one */
 	error = EINVAL;
 	for (clk = 0; clk < NUM_SYSCLOCKS; clk++) {
-		if (strncmp(newclock, sysclocks[clk],
-		    MAX_SYSCLOCK_NAME_LEN - 1)) {
+		if (strncmp(newclock, sysclocks[clk], MAX_SYSCLOCK_NAME_LEN - 1)) {
+			ffclock_last_tick(&ffcount, &bt, 0);
+			printf(" %d\t                    inloop %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   			ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
 			continue;
@@ -225,5 +229,11 @@
 		error = 0;
+		ffclock_last_tick(&ffcount, &bt, 0);
+		printf(" %d\t                    afloop %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   		ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
 		break;
 	}
-done:
+	ffclock_last_tick(&ffcount, &bt, 0);
+	printf(" %d\t                    atend  %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   	ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
+	
 	return (error);
@@ -235,3 +245,3 @@
 
-static int sysctl_kern_ffclock_ffcounter_bypass = 0;
+int sysctl_kern_ffclock_ffcounter_bypass=0;
 SYSCTL_INT(_kern_sysclock_ffclock, OID_AUTO, ffcounter_bypass, CTLFLAG_RW,
@@ -246,3 +256,2 @@
 {
-
 	ffclock_abstime(NULL, bt, NULL, FFCLOCK_LERP | FFCLOCK_LEAPSEC);
@@ -271,3 +280,2 @@
 {
-
 	ffclock_abstime(NULL, bt, NULL,
@@ -429,4 +437,8 @@
 	memcpy(&ffclock_estimate, &cest, sizeof(struct ffclock_estimate));
-	ffclock_updated++;
+	if (ffclock_updated == INT8_MAX)	// reset not yet processed by ffclock_windup
+		ffclock_updated = 1;
+	else
+		ffclock_updated++;
 	mtx_unlock(&ffclock_mtx);
+	
 	return (error);
@@ -463,3 +475,2 @@
 {
-
 	return (ENOSYS);
@@ -470,3 +481,2 @@
 {
-
 	return (ENOSYS);
@@ -477,3 +487,2 @@
 {
-
 	return (ENOSYS);
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_tc.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_tc.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_tc.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_tc.c	2020-08-19 11:49:42.000000000 +1000
@@ -11,4 +11,4 @@
  *
- * Portions of this software were developed by Julien Ridoux at the University
- * of Melbourne under sponsorship from the FreeBSD Foundation.
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -546,2 +546,4 @@
 	struct bintime		tick_time_lerp;
+	struct bintime		tick_time_diff;
+	struct bintime		tick_error;
 	ffcounter		tick_ffcount;
@@ -583,3 +585,3 @@
 void
-ffclock_reset_clock(struct timespec *ts)
+ffclock_setto_rtc(struct timespec *ts)
 {
@@ -594,3 +596,3 @@
 	ffclock_read_counter(&cest.update_ffcount);
-	cest.leapsec_next = 0;
+	cest.secs_to_nextupdate = 0;
 	cest.period = ((1ULL << 63) / tc->tc_frequency) << 1;
@@ -599,4 +601,5 @@
 	cest.status = FFCLOCK_STA_UNSYNC;
+	cest.leapsec_expected = 0;
 	cest.leapsec_total = 0;
-	cest.leapsec = 0;
+	cest.leapsec_next = 0;
 
@@ -607,5 +610,6 @@
 
-	printf("ffclock reset: %s (%llu Hz), time = %ld.%09lu\n", tc->tc_name,
-	    (unsigned long long)tc->tc_frequency, (long)ts->tv_sec,
-	    (unsigned long)ts->tv_nsec);
+	printf("ffclock_setto_rtc: at vcount = %llu:  %s (%llu Hz), time = %ld.%09lu\n",
+		(unsigned long long)cest.update_ffcount, tc->tc_name,
+		(unsigned long long)tc->tc_frequency, (long)ts->tv_sec,
+		(unsigned long)ts->tv_nsec);
 }
@@ -640,9 +644,67 @@
 
+
+/* Function to print out FFtimehands tick state neatly */
+static void
+printout_FFtick(struct fftimehands *ffth)
+{
+	struct ffclock_estimate *cest;
+
+	cest = &ffth->cest; 	// access FFclock data member
+	printf("-------------------------------------------------------------\n");
+	printf("Pretty printing fftimehands tick data.\n");
+	printf("cest: \n");
+	printf("*    period %llu\n",
+		(unsigned long long)cest->period);
+	printf("*    update_time: %llu.%llu [bintime]\t\t status: 0x%04X\n",
+		(unsigned long long)cest->update_time.sec,
+		(unsigned long long)cest->update_time.frac, cest->status);
+	printf("*    update_ffcount: %llu = %#llX \t secs_to_nextupdate: %u \n",
+		(unsigned long long)cest->update_ffcount,
+		(unsigned long long)cest->update_ffcount, cest->secs_to_nextupdate);
+	printf("*    errb_{abs,rate} = %lu  %lu\n",
+		(unsigned long)cest->errb_abs, (unsigned long)cest->errb_rate);
+	printf("*    leapsec_{expected,total,next}:  %llu  %d  %d\n",
+		(unsigned long long)cest->leapsec_expected,
+		cest->leapsec_total, cest->leapsec_next);
+	printf("-------------------------------------------------------------\n");
+	
+	printf("   tick_time:      %llu.%llu [bintime]\n",
+		(unsigned long long)ffth->tick_time.sec,
+		(unsigned long long)ffth->tick_time.frac);
+	printf("   tick_time_lerp: %llu.%llu [bintime]\n",
+		(unsigned long long)ffth->tick_time_lerp.sec,
+		(unsigned long long)ffth->tick_time_lerp.frac);
+	printf("   tick_time_diff: %llu.%llu [bintime]\n",
+		(unsigned long long)ffth->tick_time_diff.sec,
+		(unsigned long long)ffth->tick_time_diff.frac);
+	printf("   tick_error: %llu.%llu [bintime]\n",
+		(unsigned long long)ffth->tick_error.sec,
+		(unsigned long long)ffth->tick_error.frac);
+	
+	printf("   tick_ffcount: %llu = %#llX\n",
+		(unsigned long long)ffth->tick_ffcount,
+		(unsigned long long)ffth->tick_ffcount);
+	printf("   period_lerp %llu (u_diff: %llu %llu)\n",
+		(unsigned long long)ffth->period_lerp,
+		(unsigned long long)(ffth->period_lerp - cest->period),
+		(unsigned long long)(cest->period - ffth->period_lerp));
+	printf("   gen %u\n", (unsigned int)ffth->gen);
+
+	printf("-------------------------------------------------------------\n\n");
+}
+
+
 /*
- * Update the fftimehands.
- * Push the tick ffcount and time(s) forward based on current clock estimate.
- * The conversion from ffcounter to bintime relies on the difference clock
- * principle, whose accuracy relies on computing small time intervals. If a new
- * clock estimate has been passed by the synchronisation daemon, make it
- * current, and compute the linear interpolation for monotonic time if needed.
+ * Update the fftimehands. The updated tick state is based on the previous tick if
+ * there has been no actionable update in the FFclock parameters during the current
+ * tick (ffclock_updated <= 0), and each of the native, monotonic, and difference
+ * FFclocks advance linearly. Otherwise it is based off the updated parameters at
+ * the time of the update. The native FFclock will then jump, the monotonic clock
+ * will not (except under special conditions).  The diff clock will never
+ * jump, to ensure its intended use as a difference clock, used to measure
+ * time differences. The linear interpolation parameters of the
+ * monotonic FFclock ({tick_time,period}_lerp) are recomputed for the new tick.
+ *
+ * The instant defining the start of the new tick is the  delta=tc_delta call
+ *	from tc_windup. This is simply mirrored here in the FF counter `read'.
  */
@@ -656,10 +718,13 @@
 	uint64_t frac;
-	unsigned int polling;
 	uint8_t forward_jump, ogen;
 
-	/*
-	 * Pick the next timehand, copy current ffclock estimates and move tick
-	 * times and counter forward.
-	 */
+	/* verbosity control */
+	struct bintime bttest;
+	static u_int ccc = 0;
+	static u_int watch = 0;
+   int updatedcopy = ffclock_updated;
+	
 	forward_jump = 0;
+	
+	/* Prepare next fftimehand where tick state will be updated */
 	ffth = fftimehands->next;
@@ -668,40 +733,73 @@
 	cest = &ffth->cest;
-	bcopy(&fftimehands->cest, cest, sizeof(struct ffclock_estimate));
-	ffdelta = (ffcounter)delta;
-	ffth->period_lerp = fftimehands->period_lerp;
-
-	ffth->tick_time = fftimehands->tick_time;
-	ffclock_convert_delta(ffdelta, cest->period, &bt);
-	bintime_add(&ffth->tick_time, &bt);
-
-	ffth->tick_time_lerp = fftimehands->tick_time_lerp;
-	ffclock_convert_delta(ffdelta, ffth->period_lerp, &bt);
-	bintime_add(&ffth->tick_time_lerp, &bt);
 
+	/* Move FF counter forward to existing tick start */
+	ffdelta = (ffcounter)delta;
 	ffth->tick_ffcount = fftimehands->tick_ffcount + ffdelta;
 
-	/*
-	 * Assess the status of the clock, if the last update is too old, it is
-	 * likely the synchronisation daemon is dead and the clock is free
-	 * running.
+	/* No acceptable update in FFclock parameters to process.
+	 * Tick state update based on copy or simple projection from previous tick.
 	 */
-	if (ffclock_updated == 0) {
-		ffdelta = ffth->tick_ffcount - cest->update_ffcount;
+	if (ffclock_updated <= 0) {
+		
+		/* Update native FFclock members {cest, tick_time{_diff}, tick_error} */
+		bcopy(&fftimehands->cest, cest, sizeof(struct ffclock_estimate));
+		ffth->tick_time		= fftimehands->tick_time;
+		ffth->tick_time_diff = fftimehands->tick_time_diff;
 		ffclock_convert_delta(ffdelta, cest->period, &bt);
-		if (bt.sec > 2 * FFCLOCK_SKM_SCALE)
-			ffclock_status |= FFCLOCK_STA_UNSYNC;
+		bttest.sec = bt.sec;
+		bttest.frac = bt.frac;
+		bintime_add(&ffth->tick_time, &bt);					// bt not changed, reuse
+		bintime_add(&ffth->tick_time_diff, &bt);			// bt not changed, reuse
+		if (!bintime_cmp(&bt,&bttest,=)) {
+			printf(" %d\t ffwindup  %llu:  bt found to have changed! \n",
+   					ccc, (long long unsigned)fftimehands->tick_ffcount);
+			printf(" \t\t  old bt: %llu.%llu\n",
+					(unsigned long long)bttest.sec, (unsigned long long)bttest.frac);
+			printf(" \t\t  new bt: %llu.%llu\n",
+					(unsigned long long)bt.sec, 		(unsigned long long)bt.frac);
+			if (!watch) watch = 1;	// activate verbosity watching
+		}
+		bintime_mul(&bt, cest->errb_rate * PS_IN_BINFRAC);	// errb_rate in [ps/s]
+		bintime_add(&ffth->tick_error, &bt);
+
+		/* Update mono FFclock members {period_lerp, tick_time_lerp} */
+		ffth->period_lerp 	= fftimehands->period_lerp;
+		ffth->tick_time_lerp = fftimehands->tick_time_lerp;
+		ffclock_convert_delta(ffdelta, ffth->period_lerp, &bt);
+		bintime_add(&ffth->tick_time_lerp, &bt);
+
+		/* Check if the clock status should be set to unsynchronized.
+		 * Assessment based on age of last/current update, and the daemon's
+		 * estimate of the wait to the next update.
+		 * If the daemon's UNSYNC status is deemed too stale, it is over-ridden.
+		 */
+		if (ffclock_updated == 0) {
+//			ffdelta = ffth->tick_ffcount - cest->update_ffcount;
+//			ffclock_convert_delta(ffdelta, cest->period, &bt); // time since update
+			bt = ffth->tick_time;
+			bintime_sub(&bt, &cest->update_time);	// bt = now - timeoflastupdate
+			if (bt.sec > 3 * FFCLOCK_SKM_SCALE &&
+			    bt.sec > 3 * cest->secs_to_nextupdate)
+				ffclock_status |= FFCLOCK_STA_UNSYNC;
+		}
+		
 	}
 
-	/*
-	 * If available, grab updated clock estimates and make them current.
-	 * Recompute time at this tick using the updated estimates. The clock
-	 * estimates passed the feed-forward synchronisation daemon may result
-	 * in time conversion that is not monotonically increasing (just after
-	 * the update). time_lerp is a particular linear interpolation over the
-	 * synchronisation algo polling period that ensures monotonicity for the
-	 * clock ids requesting it.
+	/* Flag event where FFclock update entered next tick. Should be very rare. */
+	if (ffclock_estimate.update_ffcount >= ffth->tick_ffcount) {
+		printf("ffclock_windup: at vcount = %llu, ffclock update slipped into "
+		       "next tick, will process on next call. \n",
+				(unsigned long long)ffth->tick_ffcount);
+		if (!watch) watch = 1;	// activate verbosity watching
+	}
+	
+	/* An update in FFclock parameters is available in this tick.
+	 * Generate the new tick state based on this, projected from the update time.
 	 */
-	if (ffclock_updated > 0) {
+	if (ffclock_updated > 0 &&     // if an update occurred in current tick
+	    ffclock_estimate.update_ffcount < ffth->tick_ffcount) {
+		
+		/* Update native FFclock members {cest, tick_time, tick_error} */
 		bcopy(&ffclock_estimate, cest, sizeof(struct ffclock_estimate));
-		ffdelta = ffth->tick_ffcount - cest->update_ffcount;
+		ffdelta = ffth->tick_ffcount - cest->update_ffcount; // time since update
 		ffth->tick_time = cest->update_time;
@@ -709,14 +807,31 @@
 		bintime_add(&ffth->tick_time, &bt);
-
-		/* ffclock_reset sets ffclock_updated to INT8_MAX */
-		if (ffclock_updated == INT8_MAX)
+		bintime_mul(&bt, cest->errb_rate * PS_IN_BINFRAC);	// errb_rate in [ps/s]
+		bintime_addx(&bt, cest->errb_abs * NS_IN_BINFRAC);	// errb_abs in [ns]
+		ffth->tick_error = bt;
+
+		/* Update native FF difference clock member {tick_time_diff} */
+		ffth->tick_time_diff = fftimehands->tick_time_diff;
+		ffclock_convert_delta((ffcounter)delta, cest->period, &bt);
+		bintime_add(&ffth->tick_time_diff, &bt);
+			
+		/* Update mono FFclock member tick_time_lerp, standard case.
+		 *   ffclock_updated by ffclock_setto_rtc :  re-initialize
+		 *   ffclock_updated by daemon :             ensure continuity over ticks
+		 */
+		if (ffclock_updated == INT8_MAX)	{	// update set by ffclock_setto_rtc
 			ffth->tick_time_lerp = ffth->tick_time;
-
-		if (bintime_cmp(&ffth->tick_time, &ffth->tick_time_lerp, >))
-			forward_jump = 1;
-		else
-			forward_jump = 0;
-
+			if (!watch) watch = 1;	// activate verbosity watching
+		} else {
+			ffth->tick_time_lerp = fftimehands->tick_time_lerp;
+			ffclock_convert_delta((ffcounter)delta, fftimehands->period_lerp, &bt);
+			bintime_add(&ffth->tick_time_lerp, &bt);
+		}
+		
+		/* Record dirn of jump between monoFFclock and FFclock at tick-start */
+      if (bintime_cmp(&ffth->tick_time, &ffth->tick_time_lerp, >))
+			forward_jump = 1;		// else = 0
+		
+		/* Record magnitude of jump */
 		bintime_clear(&gap_lerp);
-		if (forward_jump) {
+		if (forward_jump) {		// monoFFclock < FFclock
 			gap_lerp = ffth->tick_time;
@@ -727,12 +842,9 @@
 		}
-
-		/*
-		 * The reset from the RTC clock may be far from accurate, and
-		 * reducing the gap between real time and interpolated time
-		 * could take a very long time if the interpolated clock insists
-		 * on strict monotonicity. The clock is reset under very strict
-		 * conditions (kernel time is known to be wrong and
-		 * synchronization daemon has been restarted recently.
-		 * ffclock_boottime absorbs the jump to ensure boot time is
-		 * correct and uptime functions stay consistent.
+		
+		/* Update mono FFclock member tick_time_lerp, exceptional case.
+		 * Break monotonicity by allowing monoFFclock jump to meet native FFclock
+		 * Only occurs under tight conditions to prevent a poor monoFFclock
+		 * initialization from taking a very long time to catch up to FFclock.
+		 * Also, absorb the jump into ffclock_boottime to ensure continuity of
+		 * boot uptime functions.
 		 */
@@ -746,26 +858,40 @@
 			ffth->tick_time_lerp = ffth->tick_time;
-			bintime_clear(&gap_lerp);
+			bintime_clear(&gap_lerp); // signal nothing to do to period_lerp algo
+			printf("** ffwindup:  Jumping monotonic FFclock\n" );
+			if (!watch) watch = 1;	// activate verbosity watching
 		}
 
-		ffclock_status = cest->status;
-		ffth->period_lerp = cest->period;
-
-		/*
-		 * Compute corrected period used for the linear interpolation of
-		 * time. The rate of linear interpolation is capped to 5000PPM
-		 * (5ms/s).
+		
+		/* Update mono FFclock member period_lerp
+		 * The goal of the monoFF algorithm is to reduce the gap between monoFF and the
+		 * native FF to zero by the next FFclock update. The reduction uses linear
+		 * interpolation via selecting period_lerp.  To ensure rate quality,
+		 * |period_lerp - period| is capped to 5000PPM (5ms/s).
+		 * If there is no gap, the clocks will agree throughout the new tick.
 		 */
-		if (bintime_isset(&gap_lerp)) {
-			ffdelta = cest->update_ffcount;
-			ffdelta -= fftimehands->cest.update_ffcount;
-			ffclock_convert_delta(ffdelta, cest->period, &bt);
-			polling = bt.sec;
-			bt.sec = 0;
-			bt.frac = 5000000 * (uint64_t)18446744073LL;
-			bintime_mul(&bt, polling);
-			if (bintime_cmp(&gap_lerp, &bt, >))
-				gap_lerp = bt;
+		ffth->period_lerp = cest->period;   // re-initialize
+
+		/* Keep default if no (or negligible) gap or no daemon updates yet */
+		if (bintime_isset(&gap_lerp) && cest->secs_to_nextupdate > 0) {
 
-			/* Approximate 1 sec by 1-(1/2^64) to ease arithmetic */
+			/* Calculate cap */
+			bt.sec = 0;
+			bt.frac = 5000000 * NS_IN_BINFRAC;
+			bintime_mul(&bt, cest->secs_to_nextupdate);
+			/* Determine the amount of gap to close over the next update interval */
+			if (bintime_cmp(&gap_lerp, &bt, >)) {
+				printf(" %u **  capping  gap_lerp  from %llu.%llu to %llu.%llu  [bintime]\n", ccc,
+					(long long unsigned)gap_lerp.sec,
+					(long long unsigned)gap_lerp.frac,
+					(long long unsigned)bt.sec,
+					(long long unsigned)bt.frac );
+				gap_lerp = bt;		// gap_lerp = min(gap_lerp, bt)
+			}
+	
+			/* Convert secs_to_nextupdate to counter units */
 			frac = 0;
+			frac -= 1;		// approximate 2^64 with (2^64)-1 to ease arithmetic
+			ffdelta = (frac / cest->period) * cest->secs_to_nextupdate;
+	
+			/* Store the portion of gap per cycle in frac */
 			if (gap_lerp.sec > 0) {
@@ -773,3 +899,5 @@
 				frac /= ffdelta / gap_lerp.sec;
-			}
+				//frac = (cest->period * gap_lerp.sec) / cest->secs_to_nextupdate;
+			} else
+				frac = 0;
 			frac += gap_lerp.frac / ffdelta;
@@ -780,6 +908,24 @@
 				ffth->period_lerp -= frac;
+			
+//		   if (frac==0) {  // will be inactive if gap too small
+//				printf(" %u **  warning, is a gap yet period_lerp not changed\n", ccc);
+//				printf("    **  gap_lerp.frac %llu [%lu [ns]],  ffdelta = %llu\n",
+//						(long long unsigned)gap_lerp.frac,
+//						(long unsigned)(gap_lerp.frac / NS_IN_BINFRAC),
+//						(long long unsigned)ffdelta );
+//				if (!watch) watch = 1;	// activate verbosity watching
+//			}
+//			else
+//				printf("    **  gap_lerp.frac %llu [%lu [ns]],  ffdelta = %llu\n",
+//					(long long unsigned)gap_lerp.frac,
+//					(long unsigned)(gap_lerp.frac / NS_IN_BINFRAC),
+//					(long long unsigned)ffdelta );
+				
 		}
 
-		ffclock_updated = 0;
+		ffclock_status = cest->status;
+		ffclock_updated = 0;		// signal that latest update processed
 	}
+	
+	/* Bump generation of new tick, avoiding the reserved 0 value */
 	if (++ogen == 0)
@@ -787,3 +933,56 @@
 	ffth->gen = ogen;
+	
+	if ( watch ) {
+		// if ( (fftimehands->tick_ffcount) < 3000*timehands->th_counter->tc_frequency && ccc<20) { // <10sec
+		printf(" %u\t ffwindup:  ffclock_updated = %d  Tick start = %llu \n",
+				 ccc++, updatedcopy, (long long unsigned)ffth->tick_ffcount );
+		printout_FFtick(fftimehands);		// current
+		printf("   UPDATED TO --->\n");
+		printout_FFtick(ffth);				// updated
+		watch++;
+		
+		/* testing of bypass code */
+//		int k;
+//		uint64_t rd1, rd2;
+//		u_int tc;
+//		ffcounter now;
+//
+//		sysctl_kern_ffclock_ffcounter_bypass = 0;
+//
+//		for (k=1; k<=2; k++) {
+//			rd1 = rdtsc();
+//			tc  = (uint64_t) timecounter->tc_get_timecount(timecounter);
+//			rd2 = rdtsc();
+//			printf("Bracket test for ffcounter call latency\n");
+//			printf(" rd1 = %llX\n tc  =  %llX\n rd2 = %llX  \t Diff = %llX  \t rd2-tc = %llX \n\n",
+//				(long long unsigned)rd1, (long long unsigned)tc, (long long unsigned)rd2,
+//				(long long unsigned)(rd2 - rd1), (long long unsigned)(rd2 - tc) );
+//		}
+//		for (k=1; k<=2; k++) {
+//			rd1 = rdtsc();
+//			ffclock_read_counter(&now);
+//			rd2 = rdtsc();
+//			printf("Bracket test for ffclock_read_counter call latency\n");
+//			printf(" rd1 = %llX\n now = %llX\n rd2 = %llX  \t Diff = %llX  \t rd2-now = %llX \n\n",
+//				(long long unsigned)rd1, (long long unsigned)now, (long long unsigned)rd2,
+//				(long long unsigned)(rd2 - rd1), (long long unsigned)(rd2 - now) );
+//		}
+//
+//		sysctl_kern_ffclock_ffcounter_bypass = 1;
+//
+//		for (k=1; k<=2; k++) {
+//			rd1 = rdtsc();
+//			ffclock_read_counter(&now);
+//			rd2 = rdtsc();
+//			printf("Bracket test for ffclock_read_counter call latency\n");
+//			printf(" rd1 = %llX\n now = %llX\n rd2 = %llX  \t Diff = %llX  \t rd2-now = %llX \n\n",
+//				(long long unsigned)rd1, (long long unsigned)now, (long long unsigned)rd2,
+//				(long long unsigned)(rd2 - rd1), (long long unsigned)(rd2 - now) );
+//		}
+		
+		if (watch>=3) watch = 0; 	//	switch watch off after context interval
+	}
+	
 	fftimehands = ffth;
+	
 }
@@ -792,12 +991,8 @@
  * Adjust the fftimehands when the timecounter is changed. Stating the obvious,
- * the old and new hardware counter cannot be read simultaneously. tc_windup()
- * does read the two counters 'back to back', but a few cycles are effectively
- * lost, and not accumulated in tick_ffcount. This is a fairly radical
- * operation for a feed-forward synchronization daemon, and it is its job to not
- * pushing irrelevant data to the kernel. Because there is no locking here,
- * simply force to ignore pending or next update to give daemon a chance to
- * realize the counter has changed.
+ * the old and new hardware counter cannot be read simultaneously.
+ * Because there is no locking here, simply force to ignore pending or next
+ * update to give daemon a chance to realize the counter has changed.
  */
 static void
-ffclock_change_tc(struct timehands *th)
+ffclock_change_tc(struct timehands *th, u_int ncount)
 {
@@ -807,4 +1002,7 @@
 	uint8_t ogen;
+	ffcounter now;
 
 	tc = th->th_counter;
+	
+	/* Prepare next fftimehand where tick state will be updated */
 	ffth = fftimehands->next;
@@ -812,5 +1010,26 @@
 	ffth->gen = 0;
-
 	cest = &ffth->cest;
+	
+	/* Reset FFcounter to match start of current tick.
+	 *  If a TSC derived counter, get correct higher order bits to ensure the
+	 *  FFcounter origin matches that of the counter, rather than the time the
+	 *  counter was adopted. If not TSC, the origin will be ncount in the past.
+	 *  In all cases, the lower of FFcounter and th_offset_count will agree.
+	 */
+	if ( strcmp(tc->tc_name, "TSC") != 0 )
+		ffth->tick_ffcount = (ffcounter)ncount;  // origin matches timehands
+	else {
+		now = (ffcounter) rdtsc();
+		if (strcmp(tc->tc_name, "TSC-low") == 0) // TSC reads are shifted
+			now >>= (int)(intptr_t)tc->tc_priv;
+		/* reconstruct the counter value at the time ncount was taken */
+		ffth->tick_ffcount = now - (ffcounter)((u_int)now - ncount);
+	}
+	
+	/* This update does not advance the tick itself, intead it reinitiates when
+	 * existing values are not appropriate for the new counter.
+	 */
 	bcopy(&(fftimehands->cest), cest, sizeof(struct ffclock_estimate));
+	cest->update_ffcount = 0;		// cest->update_time still valid, so retained
+	cest->secs_to_nextupdate = 0;
 	cest->period = ((1ULL << 63) / tc->tc_frequency ) << 1;
@@ -819,11 +1038,23 @@
 	cest->status |= FFCLOCK_STA_UNSYNC;
+	cest->leapsec_expected = 0;
+	cest->leapsec_total = 0;
+	cest->leapsec_next = 0;
 
-	ffth->tick_ffcount = fftimehands->tick_ffcount;
-	ffth->tick_time_lerp = fftimehands->tick_time_lerp;
 	ffth->tick_time = fftimehands->tick_time;
+	ffth->tick_error = fftimehands->tick_error;
+	ffth->tick_time_diff = fftimehands->tick_time_diff;
+	ffth->tick_time_lerp = fftimehands->tick_time_lerp;
 	ffth->period_lerp = cest->period;
+	
+	/* Push reset FFdata to the global variable */
+	mtx_lock(&ffclock_mtx);
+	bcopy(cest,&ffclock_estimate, sizeof(struct ffclock_estimate));
+	mtx_unlock(&ffclock_mtx);
 
 	/* Do not lock but ignore next update from synchronization daemon. */
-	ffclock_updated--;
-
+	if (ffclock_updated == INT8_MAX)	// reset not yet processed by ffclock_windup
+		ffclock_updated = -1;
+	else
+		ffclock_updated--;
+	
 	if (++ogen == 0)
@@ -832,2 +1063,7 @@
 	fftimehands = ffth;
+	
+	printf("ffclock_change_tc: new tick_ffcount = %llu = %#llX, with tc %s (%llu Hz)\n",
+		(unsigned long long)ffth->tick_ffcount,
+		(unsigned long long)ffth->tick_ffcount,
+		tc->tc_name, (unsigned long long)tc->tc_frequency);
 }
@@ -922,2 +1158,3 @@
  * Access to current ffcounter value.
+ * If bypass mode on, assume the counter is TSC, and access it directly.
  */
@@ -930,2 +1167,7 @@
 
+	if (sysctl_kern_ffclock_ffcounter_bypass == 1) {
+		*ffcount = (ffcounter) rdtsc();
+		return;
+	}
+	
 	/*
@@ -1062,4 +1304,6 @@
 /*
- * Take a snapshot of sysclock data which can be used to compare system clocks
- * and generate timestamps after the fact.
+ * Take a raw timestamp (timecounter reading), and then snapshot the sysclock
+ * data which can be used to compare system clocks and generate timestamps
+ * of all possible types after the fact.
+ * If bypass mode on, assume the counter is TSC, and access it directly.
  */
@@ -1073,13 +1317,8 @@
 #ifdef FFCLOCK
-	ffcounter ffcount;
-	struct fftimehands *ffth;
 	struct ffclock_info *ffi;
+	struct fftimehands *ffth;
 	struct ffclock_estimate cest;
-
-	ffi = &clock_snap->ff_info;
 #endif
 
-	fbi = &clock_snap->fb_info;
 	delta = 0;
-
 	do {
@@ -1087,2 +1326,11 @@
 		gen = atomic_load_acq_int(&th->th_generation);
+		if (!fast) {
+#ifdef FFCLOCK
+			if (sysctl_kern_ffclock_ffcounter_bypass == 1)
+				delta = rdtsc32() - th->th_offset_count;
+			else
+#endif
+				delta = tc_delta(th);
+		}
+		fbi = &clock_snap->fb_info;
 		fbi->th_scale = th->th_scale;
@@ -1090,4 +1338,6 @@
 #ifdef FFCLOCK
+		ffi = &clock_snap->ff_info;
 		ffth = fftimehands;
 		ffi->tick_time = ffth->tick_time_lerp;
+		ffi->tick_time_diff = ffth->tick_time_diff;
 		ffi->tick_time_lerp = ffth->tick_time_lerp;
@@ -1098,4 +1348,2 @@
 #endif
-		if (!fast)
-			delta = tc_delta(th);
 		atomic_thread_fence_acq();
@@ -1107,8 +1355,7 @@
 	/* Record feedback clock status and error. */
-	clock_snap->fb_info.status = time_status;
+	fbi->status = time_status;
 	/* XXX: Very crude estimate of feedback clock error. */
-	bt.sec = time_esterror / 1000000;
-	bt.frac = ((time_esterror - bt.sec) * 1000000) *
-	    (uint64_t)18446744073709ULL;
-	clock_snap->fb_info.error = bt;
+	bt.sec = time_esterror / 1000000;			// time_esterror is in mus
+	bt.frac = (time_esterror - bt.sec * 1000000) * MUS_IN_BINFRAC;
+	fbi->error = bt;
 
@@ -1118,16 +1365,17 @@
 
-	/* Record feed-forward clock leap second adjustment. */
+	/* Precalculate total leap second adjustment appropriate to this ffcount.
+	 * Includes total leaps so far and impending leap ffcount may have surpassed.
+	 */
 	ffi->leapsec_adjustment = cest.leapsec_total;
-	if (clock_snap->ffcount > cest.leapsec_next)
-		ffi->leapsec_adjustment -= cest.leapsec;
+	if (cest.leapsec_expected != 0 && clock_snap->ffcount > cest.leapsec_expected)
+		ffi->leapsec_adjustment += cest.leapsec_next;
 
 	/* Record feed-forward clock status and error. */
-	clock_snap->ff_info.status = cest.status;
-	ffcount = clock_snap->ffcount - cest.update_ffcount;
-	ffclock_convert_delta(ffcount, cest.period, &bt);
-	/* 18446744073709 = int(2^64/1e12), err_bound_rate in [ps/s]. */
-	bintime_mul(&bt, cest.errb_rate * (uint64_t)18446744073709ULL);
-	/* 18446744073 = int(2^64 / 1e9), since err_abs in [ns]. */
-	bintime_addx(&bt, cest.errb_abs * (uint64_t)18446744073ULL);
-	clock_snap->ff_info.error = bt;
+	ffi->status = cest.status;
+	ffi->error = ffth->tick_error;
+	if (!fast) {
+		ffclock_convert_delta((ffcounter)delta, cest.period, &bt);
+		bintime_mul(&bt, cest.errb_rate * PS_IN_BINFRAC);	// errb_rate in [ps/s]
+		bintime_add(&ffi->error, &bt);
+	}
 #endif
@@ -1137,3 +1385,4 @@
  * Convert a sysclock snapshot into a struct bintime based on the specified
- * clock source and flags.
+ * clock paradigm, and flags.
+ * wantUptime and wantLerp superceed wantDiff if (erroneously) used together
  */
@@ -1141,3 +1390,3 @@
 sysclock_snap2bintime(struct sysclock_snap *cs, struct bintime *bt,
-    int whichclock, uint32_t flags)
+    int whichclock, int wantFast, int wantUptime, int wantLerp, int wantDiff)
 {
@@ -1154,6 +1403,7 @@
 		/* If snapshot was created with !fast, delta will be >0. */
-		if (cs->delta > 0)
+		if (!wantFast && cs->delta > 0)
 			bintime_addx(bt, cs->fb_info.th_scale * cs->delta);
 
-		if ((flags & FBCLOCK_UPTIME) == 0) {
+		/* Native FBclock is Uptime, need to adjust if want UTC */
+		if (!wantUptime) {
 			getboottimebin(&boottimebin_x);
@@ -1164,8 +1414,11 @@
 	case SYSCLOCK_FFWD:
-		if (flags & FFCLOCK_LERP) {
-			*bt = cs->ff_info.tick_time_lerp;
+		if (wantLerp) {	// Lerp supercedes Diff
 			period = cs->ff_info.period_lerp;
+			*bt = cs->ff_info.tick_time_lerp;
 		} else {
-			*bt = cs->ff_info.tick_time;
 			period = cs->ff_info.period;
+			if (wantDiff)
+				*bt = cs->ff_info.tick_time_diff;
+			else
+				*bt = cs->ff_info.tick_time;
 		}
@@ -1173,4 +1426,4 @@
 		/* If snapshot was created with !fast, delta will be >0. */
-		if (cs->delta > 0) {
-			ffclock_convert_delta(cs->delta, period, &bt2);
+		if (!wantFast && cs->delta > 0) {
+			ffclock_convert_delta((ffcounter)cs->delta, period, &bt2);
 			bintime_add(bt, &bt2);
@@ -1178,9 +1431,9 @@
 
-		/* Leap second adjustment. */
-		if (flags & FFCLOCK_LEAPSEC)
-			bt->sec -= cs->ff_info.leapsec_adjustment;
-
-		/* Boot time adjustment, for uptime/monotonic clocks. */
-		if (flags & FFCLOCK_UPTIME)
+		/* Add appropriate constant to create Uptime, UTC, or Diff FF clock */
+		if (wantUptime) // Uptime superceded Diff
 			bintime_sub(bt, &ffclock_boottime);
+		else
+			if (!wantDiff)				 // UTC
+				bt->sec -= cs->ff_info.leapsec_adjustment;
+			// else Diff
 		break;
@@ -1426,2 +1679,5 @@
 	if (th->th_counter != timecounter) {
+		printf("Changing tc counter on this tc-tick:  %s = %#X --> %s = %#X \n",
+			th->th_counter->tc_name, th->th_offset_count,
+			timecounter->tc_name, ncount);
 #ifndef __arm__
@@ -1437,3 +1693,3 @@
 #ifdef FFCLOCK
-		ffclock_change_tc(th);
+		ffclock_change_tc(th,ncount);
 #endif
@@ -1487,4 +1743,8 @@
 	case SYSCLOCK_FFWD:
-		time_second = fftimehands->tick_time_lerp.sec;
-		time_uptime = fftimehands->tick_time_lerp.sec - ffclock_boottime.sec;
+		ffclock_getbintime(&bt);
+		time_second = bt.sec;
+		//time_second = fftimehands->tick_time_lerp.sec;   // wrong, leaps not added!
+		ffclock_getbinuptime(&bt);
+		time_uptime = bt.sec;
+		//time_uptime = fftimehands->tick_time_lerp.sec - ffclock_boottime.sec;
 		break;
@@ -1504,2 +1764,5 @@
 	int error;
+	struct bintime bt;
+	ffcounter ffcount;
+	static int ccc = 0;
 
@@ -1508,3 +1771,8 @@
 
+	ffclock_last_tick(&ffcount, &bt, 0);
+	//printf(" %d\t Callback tc_hardware start  %llu:  newname= %s \n",
+   //	ccc++, (long long unsigned)ffcount, newname);
+
 	error = sysctl_handle_string(oidp, &newname[0], sizeof(newname), req);
+	
 	if (error != 0 || req->newptr == NULL)
@@ -1519,2 +1787,4 @@
 
+		printf(" %d\t Callback tc_hardware inloop  %llu:  newname= %s  error= %d\n",
+   	ccc++, (long long unsigned)ffcount, newname, error);
 		/* Warm up new timecounter. */
@@ -1992,2 +2262,10 @@
 	/* warm up new timecounter (again) and get rolling. */
+//	int k;
+//	uint64_t rd1, rd2;
+//	u_int tc;
+//
+//	rd1 = rdtsc();
+//	printf(" *** inittimecounter before windup:  (th_offset_count,tick_ffcount) = (%X, %llX)     (TSC = %#llX = %llu)\n",
+//		timehands->th_offset_count,
+//		(long long unsigned)fftimehands->tick_ffcount, (long long unsigned)rd1, (long long unsigned)rd1 );
 	(void)timecounter->tc_get_timecount(timecounter);
@@ -1996,2 +2274,6 @@
 	tc_windup(NULL);
+//	rd2 = rdtsc();
+//	printf(" *** inittimecounter after  windup:  (th_offset_count,tick_ffcount) = (%X, %llX)    (TSC = %#llX = %llu)\n",
+//		timehands->th_offset_count,
+//		(long long unsigned)fftimehands->tick_ffcount, (long long unsigned)rd2, (long long unsigned)rd2 );
 	mtx_unlock_spin(&tc_setclock_mtx);
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/subr_rtc.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/subr_rtc.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/subr_rtc.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/subr_rtc.c	2020-08-19 11:49:42.000000000 +1000
@@ -11,4 +11,4 @@
  *
- * Portions of this software were developed by Julien Ridoux at the University
- * of Melbourne under sponsorship from the FreeBSD Foundation.
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -360,3 +360,3 @@
 #ifdef FFCLOCK
-		ffclock_reset_clock(&ts);
+		ffclock_setto_rtc(&ts);
 #endif
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/timeffc.h /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/timeffc.h
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/timeffc.h	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/timeffc.h	2020-08-19 11:49:42.000000000 +1000
@@ -4,4 +4,4 @@
  *
- * This software was developed by Julien Ridoux at the University of Melbourne
- * under sponsorship from the FreeBSD Foundation.
+ * This software was developed by Julien Ridoux and Darryl Veitch at the 
+ * University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -28,3 +28,3 @@
  *
- * $FreeBSD: releng/11.2/sys/sys/timeffc.h 331722 2018-03-29 02:50:57Z eadler $
+ * $FreeBSD$
  */
@@ -43,13 +43,21 @@
 struct ffclock_estimate {
-	struct bintime	update_time;	/* Time of last estimates update. */
-	ffcounter	update_ffcount;	/* Counter value at last update. */
-	ffcounter	leapsec_next;	/* Counter value of next leap second. */
-	uint64_t	period;		/* Estimate of counter period. */
-	uint32_t	errb_abs;	/* Bound on absolute clock error [ns]. */
-	uint32_t	errb_rate;	/* Bound on counter rate error [ps/s]. */
-	uint32_t	status;		/* Clock status. */
-	int16_t		leapsec_total;	/* All leap seconds seen so far. */
-	int8_t		leapsec;	/* Next leap second (in {-1,0,1}). */
+	struct bintime	update_time;	/* FFclock time of last update, ie Ca(tlast) */
+	ffcounter	update_ffcount;	/* Counter value at last update */
+	ffcounter	leapsec_expected;	/* Estimated counter value of next leap sec */
+	uint64_t	period;				/* Estimate of current counter period [2^-64 s] */
+	uint32_t	errb_abs;				/* Bound on absolute clock error [ns] */
+	uint32_t	errb_rate;			/* Bound on relative counter period err [ps/s] */
+	uint32_t	status;					/* Clock status */
+	uint16_t	secs_to_nextupdate;	/* Estimated wait til next update [s] */
+	int8_t	leapsec_total;			/* Sum of leap secs seen since clock start */
+	int8_t	leapsec_next;			/* Next leap second (in {-1,0,1}) */
 };
 
+/* Constants to hold errors and error rates in 64bit binary fraction fields */
+#define	MS_IN_BINFRAC	(uint64_t)18446744073709551ULL	// floor(2^64/1e3)
+#define	MUS_IN_BINFRAC	(uint64_t)18446744073709ULL		// floor(2^64/1e6)
+#define	NS_IN_BINFRAC	(uint64_t)18446744073ULL			// floor(2^64/1e9)
+#define	PS_IN_BINFRAC	(uint64_t)18446744ULL				// floor(2^64/1e12)
+
+
 #if __BSD_VISIBLE
@@ -57,8 +65,15 @@
 
-/* Define the kern.sysclock sysctl tree. */
+/* Declare the kern.sysclock sysctl tree. */
 SYSCTL_DECL(_kern_sysclock);
 
-/* Define the kern.sysclock.ffclock sysctl tree. */
+/* Declare the kern.sysclock.ffclock sysctl tree. */
 SYSCTL_DECL(_kern_sysclock_ffclock);
 
+/* Flag defining if counter bypass mode is desired or not.
+ * This is only possible if the counter is a TSC with rdtsc defined.
+ */
+#ifdef FFCLOCK
+extern int sysctl_kern_ffclock_ffcounter_bypass;
+#endif
+
 /*
@@ -86,2 +101,3 @@
  * converted into absolute time.
+ * The flags all set independent bits and so are OR-able.
  * {FB|FF}CLOCK_FAST:	Do not read the hardware counter, instead using the
@@ -96,3 +112,3 @@
 #define	FFCLOCK_LERP		0x00000002
-#define	FFCLOCK_LEAPSEC		0x00000004
+#define	FFCLOCK_LEAPSEC	0x00000004
 #define	FFCLOCK_UPTIME		0x00000008
@@ -100,3 +116,3 @@
 
-#define	FBCLOCK_FAST		0x00010000 /* Currently unused. */
+#define	FBCLOCK_FAST		0x00010000 /* Currently unused */
 #define	FBCLOCK_UPTIME		0x00020000
@@ -125,2 +141,3 @@
 	struct bintime		tick_time;
+	struct bintime		tick_time_diff;
 	struct bintime		tick_time_lerp;
@@ -151,6 +168,6 @@
 int sysclock_snap2bintime(struct sysclock_snap *cs, struct bintime *bt,
-    int whichclock, uint32_t flags);
+    int whichclock, int wantFast, int wantUptime, int wantLerp, int wantDiff);
 
 /* Resets feed-forward clock from RTC */
-void ffclock_reset_clock(struct timespec *ts);
+void ffclock_setto_rtc(struct timespec *ts);
 
