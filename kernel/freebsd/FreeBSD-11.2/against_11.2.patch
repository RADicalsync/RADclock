diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/_ffcounter.h /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/_ffcounter.h
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/_ffcounter.h	2019-11-15 19:46:12.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/_ffcounter.h	2019-12-09 11:47:13.000000000 +1100
@@ -4,4 +4,4 @@
  *
- * This software was developed by Julien Ridoux at the University of Melbourne
- * under sponsorship from the FreeBSD Foundation.
+ * This software was developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.c	2019-11-27 15:20:31.000000000 +1100
@@ -9,2 +9,5 @@
  *
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
+ *
  * Redistribution and use in source and binary forms, with or without
@@ -41,2 +44,3 @@
 #include "opt_compat.h"
+#include "opt_ffclock.h"
 #include "opt_ddb.h"
@@ -60,2 +64,3 @@
 #include <sys/sockio.h>
+#include <sys/timeffc.h>
 #include <sys/ttycom.h>
@@ -112,2 +117,4 @@
 	int		bif_flags;	/* Interface flags */
+//	struct sysctl_oid *tscfgoid;	/* timestamp sysctl oid for interface */
+//	int tstype;							/* if-level timestamp interface */
 	struct bpf_if	**bif_bpf;	/* Pointer to pointer to us */
@@ -138,2 +145,3 @@
 	struct timeval32 bh_tstamp;	/* time stamp */
+	ffcounter	bh_ffcounter;	/* feed-forward counter stamp */
 	uint32_t	bh_caplen;	/* length of captured portion */
@@ -143,3 +151,3 @@
 };
-#endif
+#endif /* !BURN_BRIDGES */
 
@@ -161,3 +169,26 @@
 #define	BIOCSETFNR32	_IOW('B', 130, struct bpf_program32)
-#endif
+#endif /* COMPAT_FREEBSD32 */
+
+/*
+ * Safety belt to ensure ABI of structs bpf_hdr32, bpf_hdr and bpf_xhdr are
+ * preserved for use with FFCLOCK, which changes the stamp field in the
+ * structs to allow storing a regular time stamp or ffcounter stamp.
+ */
+CTASSERT(sizeof(struct bpf_ts) >= sizeof(ffcounter) &&
+    sizeof(struct bintime) >= sizeof(ffcounter));
+
+//static const char *bpfiftstypes[] = {
+//	"default",
+//#define	BPF_TSTAMP_DEFAULT	0
+//	"none",
+//#define	BPF_TSTAMP_NONE		1
+//	"fast",
+//#define	BPF_TSTAMP_FAST		2
+//	"normal",
+//#define	BPF_TSTAMP_NORMAL	3
+//	"external"
+//#define	BPF_TSTAMP_EXTERNAL	4
+//};
+//#define	NUM_BPFIFTSTYPES	(sizeof(bpfiftstypes) / sizeof(*bpfiftstypes))
+
 
@@ -188,3 +219,7 @@
 		    void (*)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+#ifdef FFCLOCK
+		    struct bintime *, ffcounter *);
+#else
 		    struct bintime *);
+#endif
 static void	reset_d(struct bpf_d *);
@@ -197,2 +232,3 @@
 static int	bpf_stats_sysctl(SYSCTL_HANDLER_ARGS);
+//static int	bpf_tscfg_sysctl_handler(SYSCTL_HANDLER_ARGS);
 
@@ -207,2 +243,8 @@
     bpf_stats_sysctl, "bpf statistics portal");
+//static SYSCTL_NODE(_net_bpf, OID_AUTO, tscfg, CTLFLAG_RW, NULL,
+//    "Per-interface timestamp configuration");
+//static int bpf_default_tstype = BPF_TSTAMP_NORMAL;
+//SYSCTL_PROC(_net_bpf_tscfg, OID_AUTO, default,
+//    CTLTYPE_STRING | CTLFLAG_RW, NULL, 0, bpf_tscfg_sysctl_handler, "A",
+//    "Per-interface system wide default timestamp configuration");
 
@@ -1683,3 +1725,2 @@
 			u_int	func;
-
 			func = *(u_int *)addr;
@@ -2078,44 +2119,2 @@
 
-#define	BPF_TSTAMP_NONE		0
-#define	BPF_TSTAMP_FAST		1
-#define	BPF_TSTAMP_NORMAL	2
-#define	BPF_TSTAMP_EXTERN	3
-
-static int
-bpf_ts_quality(int tstype)
-{
-
-	if (tstype == BPF_T_NONE)
-		return (BPF_TSTAMP_NONE);
-	if ((tstype & BPF_T_FAST) != 0)
-		return (BPF_TSTAMP_FAST);
-
-	return (BPF_TSTAMP_NORMAL);
-}
-
-static int
-bpf_gettime(struct bintime *bt, int tstype, struct mbuf *m)
-{
-	struct m_tag *tag;
-	int quality;
-
-	quality = bpf_ts_quality(tstype);
-	if (quality == BPF_TSTAMP_NONE)
-		return (quality);
-
-	if (m != NULL) {
-		tag = m_tag_locate(m, MTAG_BPF, MTAG_BPF_TIMESTAMP, NULL);
-		if (tag != NULL) {
-			*bt = *(struct bintime *)(tag + 1);
-			return (BPF_TSTAMP_EXTERN);
-		}
-	}
-	if (quality == BPF_TSTAMP_NORMAL)
-		binuptime(bt);
-	else
-		getbinuptime(bt);
-
-	return (quality);
-}
-
 /*
@@ -2130,3 +2129,5 @@
 	struct bintime bt;
+	struct sysclock_snap cs;
 	struct bpf_d *d;
+	u_int slen;
 #ifdef BPF_JITTER
@@ -2134,7 +2135,6 @@
 #endif
-	u_int slen;
-	int gottime;
-
-	gottime = BPF_TSTAMP_NONE;
 
+	/* Obtain state data for both FF and FB clocks */
+	sysclock_getsnapshot(&cs, 0);
+	
 	BPFIF_RLOCK(bp);
@@ -2144,6 +2144,4 @@
 		 * We are not using any locks for d here because:
-		 * 1) any filter change is protected by interface
-		 * write lock
-		 * 2) destroying/detaching d is protected by interface
-		 * write lock, too
+		 * 1) any filter change is protected by interface write lock
+		 * 2) destroying/detaching d is protected by interface write lock, too
 		 */
@@ -2172,4 +2170,19 @@
 			d->bd_fcount++;
-			if (gottime < bpf_ts_quality(d->bd_tstamp))
-				gottime = bpf_gettime(&bt, d->bd_tstamp, NULL);
+			
+			/* Obtain ts if requested, no external ts in bpf_tap case */
+			if ( BPF_T_FORMAT(d->bd_tstamp)!=BPF_T_NONE ) {
+				if ( (sysclock_active==SYSCLOCK_FBCK
+						&& BPF_T_CLOCK(d->bd_tstamp)==BPF_T_SYSCLOCK)
+						|| BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FBCLOCK )
+					sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FBCK,
+						d->bd_tstamp & BPF_T_FAST,
+						d->bd_tstamp & BPF_T_MONOTONIC, 0);
+				else
+					sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FFWD,
+						d->bd_tstamp & BPF_T_FAST,
+						d->bd_tstamp & BPF_T_MONOTONIC,
+						BPF_T_CLOCK(d->bd_tstamp)!= BPF_T_FFNATIVECLOCK );
+			}	else
+				bzero(&bt, sizeof(bt));
+
 #ifdef MAC
@@ -2177,4 +2190,16 @@
 #endif
-				catchpacket(d, pkt, pktlen, slen,
-				    bpf_append_bytes, &bt);
+#ifdef FFCLOCK
+			{
+				printf(" ** in bpf_tap **\n");
+				ffcounter ffcount = 0;
+				if (BPF_T_FFRAW(d->bd_tstamp) == BPF_T_FFC)
+					catchpacket(d, pkt, pktlen, slen,
+						bpf_append_mbuf, &bt, &cs.ffcount);
+				else
+					catchpacket(d, pkt, pktlen, slen,
+						bpf_append_mbuf, &bt, &ffcount);
+			}
+#else
+				catchpacket(d, pkt, pktlen, slen, bpf_append_bytes, &bt);
+#endif
 			BPFD_UNLOCK(d);
@@ -2197,3 +2222,6 @@
 	struct bintime bt;
+	struct sysclock_snap cs;
 	struct bpf_d *d;
+	struct m_tag *tag;
+	u_int pktlen, slen;
 #ifdef BPF_JITTER
@@ -2201,4 +2229,2 @@
 #endif
-	u_int pktlen, slen;
-	int gottime;
 
@@ -2210,4 +2236,6 @@
 
+	/* Obtain state data for both FF and FB clocks */
+	sysclock_getsnapshot(&cs, 0);
+
 	pktlen = m_length(m, NULL);
-	gottime = BPF_TSTAMP_NONE;
 
@@ -2229,6 +2257,25 @@
 			BPFD_LOCK(d);
-
+			
 			d->bd_fcount++;
-			if (gottime < bpf_ts_quality(d->bd_tstamp))
-				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+
+			/* Obtain ts if requested, and not already supplied externally */
+			if ( BPF_T_FORMAT(d->bd_tstamp)!=BPF_T_NONE ) {
+				tag = m_tag_locate(m, MTAG_BPF, MTAG_BPF_TIMESTAMP, NULL);
+				if (tag != NULL)	// if external ts available, use it
+					bt = *(struct bintime *)(tag + 1);
+				else
+					if ( (sysclock_active==SYSCLOCK_FBCK
+							&& BPF_T_CLOCK(d->bd_tstamp)==BPF_T_SYSCLOCK)
+							|| BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FBCLOCK )
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FBCK,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC, 0);
+					else
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FFWD,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC,
+							BPF_T_CLOCK(d->bd_tstamp)!= BPF_T_FFNATIVECLOCK );
+			} else
+				bzero(&bt, sizeof(bt));
+				
 #ifdef MAC
@@ -2236,4 +2283,16 @@
 #endif
-				catchpacket(d, (u_char *)m, pktlen, slen,
-				    bpf_append_mbuf, &bt);
+#ifdef FFCLOCK
+				{
+					printf(" ** in bpf_mtap **\n");
+					ffcounter ffcount = 0;
+					if (BPF_T_FFRAW(d->bd_tstamp) == BPF_T_FFC)
+						catchpacket(d, (u_char *)m, pktlen, slen,
+							bpf_append_mbuf, &bt, &cs.ffcount);
+					else
+						catchpacket(d, (u_char *)m, pktlen, slen,
+							bpf_append_mbuf, &bt, &ffcount);
+				}
+#else
+				catchpacket(d, (u_char *)m, pktlen, slen, bpf_append_mbuf, &bt);
+#endif
 			BPFD_UNLOCK(d);
@@ -2252,6 +2311,7 @@
 	struct bintime bt;
+	struct sysclock_snap cs;
 	struct mbuf mb;
 	struct bpf_d *d;
+	struct m_tag *tag;
 	u_int pktlen, slen;
-	int gottime;
 
@@ -2263,2 +2323,5 @@
 
+	/* Obtain state data for both FF and FB clocks */
+	sysclock_getsnapshot(&cs, 0);
+	
 	pktlen = m_length(m, NULL);
@@ -2274,4 +2337,2 @@
 
-	gottime = BPF_TSTAMP_NONE;
-
 	BPFIF_RLOCK(bp);
@@ -2287,4 +2348,22 @@
 			d->bd_fcount++;
-			if (gottime < bpf_ts_quality(d->bd_tstamp))
-				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+
+			/* Obtain ts if requested, and not already supplied externally */
+			if ( BPF_T_FORMAT(d->bd_tstamp)!=BPF_T_NONE ) {
+				tag = m_tag_locate(m, MTAG_BPF, MTAG_BPF_TIMESTAMP, NULL);
+				if (tag != NULL)	// if external ts available, use it
+					bt = *(struct bintime *)(tag + 1);
+				else
+					if ( (sysclock_active==SYSCLOCK_FBCK
+							&& BPF_T_CLOCK(d->bd_tstamp)==BPF_T_SYSCLOCK)
+							|| BPF_T_CLOCK(d->bd_tstamp)==BPF_T_FBCLOCK )
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FBCK,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC, 0);
+					else
+						sysclock_snap2bintime(&cs, &bt, SYSCLOCK_FFWD,
+							d->bd_tstamp & BPF_T_FAST,
+							d->bd_tstamp & BPF_T_MONOTONIC,
+							BPF_T_CLOCK(d->bd_tstamp)!= BPF_T_FFNATIVECLOCK );
+			} else
+				bzero(&bt, sizeof(bt));
 #ifdef MAC
@@ -2292,4 +2371,16 @@
 #endif
-				catchpacket(d, (u_char *)&mb, pktlen, slen,
-				    bpf_append_mbuf, &bt);
+#ifdef FFCLOCK
+				{
+					printf(" ** in bpf_tap2 **\n");
+					ffcounter ffcount = 0;
+					if (BPF_T_FFRAW(d->bd_tstamp) == BPF_T_FFC)
+						catchpacket(d, (u_char *)&mb, pktlen, slen,
+							bpf_append_mbuf, &bt, &cs.ffcount);
+					else
+						catchpacket(d, (u_char *)&mb, pktlen, slen,
+							bpf_append_mbuf, &bt, &ffcount);
+				}
+#else
+				catchpacket(d, (u_char *)&mb, pktlen, slen, bpf_append_mbuf, &bt);
+#endif
 			BPFD_UNLOCK(d);
@@ -2302,7 +2393,2 @@
 
-#undef	BPF_TSTAMP_NONE
-#undef	BPF_TSTAMP_FAST
-#undef	BPF_TSTAMP_NORMAL
-#undef	BPF_TSTAMP_EXTERN
-
 static int
@@ -2338,3 +2424,2 @@
 {
-	struct bintime bt2, boottimebin;
 	struct timeval tsm;
@@ -2342,8 +2427,2 @@
 
-	if ((tstype & BPF_T_MONOTONIC) == 0) {
-		bt2 = *bt;
-		getboottimebin(&boottimebin);
-		bintime_add(&bt2, &boottimebin);
-		bt = &bt2;
-	}
 	switch (BPF_T_FORMAT(tstype)) {
@@ -2376,3 +2455,7 @@
     void (*cpfn)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+#ifdef FFCLOCK
+    struct bintime *bt, ffcounter *ffcount)
+#else
     struct bintime *bt)
+#endif
 {
@@ -2431,2 +2514,3 @@
 		curlen = BPF_WORDALIGN(d->bd_slen);
+
 	if (curlen + totlen > d->bd_bufsize || !bpf_canwritebuf(d)) {
@@ -2435,4 +2519,3 @@
 			 * There's no room in the store buffer, and no
-			 * prospect of room, so drop the packet.  Notify the
-			 * buffer model.
+			 * prospect of room, so drop the packet.  Notify the buffer model.
 			 */
@@ -2453,7 +2536,8 @@
 		do_wakeup = 1;
+
 	caplen = totlen - hdrlen;
 	tstype = d->bd_tstamp;
-	do_timestamp = tstype != BPF_T_NONE;
+	do_timestamp = BPF_T_FORMAT(tstype) != BPF_T_NONE;
 #ifndef BURN_BRIDGES
-	if (tstype == BPF_T_NONE || BPF_T_FORMAT(tstype) == BPF_T_MICROTIME) {
+	if (BPF_T_FORMAT(tstype)==BPF_T_NONE || BPF_T_FORMAT(tstype)==BPF_T_MICROTIME) {
 		struct bpf_ts ts;
@@ -2468,2 +2552,5 @@
 			}
+#ifdef FFCLOCK
+			hdr32_old.bh_ffcounter = *ffcount;
+#endif
 			hdr32_old.bh_datalen = pktlen;
@@ -2471,4 +2558,3 @@
 			hdr32_old.bh_caplen = caplen;
-			bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr32_old,
-			    sizeof(hdr32_old));
+			bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr32_old, sizeof(hdr32_old));
 			goto copy;
@@ -2481,2 +2567,5 @@
 		}
+#ifdef FFCLOCK
+		hdr_old.bh_ffcounter = *ffcount;
+#endif
 		hdr_old.bh_datalen = pktlen;
@@ -2492,3 +2581,3 @@
 	 * Append the bpf header.  Note we append the actual header size, but
-	 * move forward the length of the header plus padding.
+	 * later only move forward by hdrlen (bpf-aligned trailing padding)
 	 */
@@ -2497,2 +2586,5 @@
 		bpf_bintime2ts(bt, &hdr.bh_tstamp, tstype);
+#ifdef FFCLOCK
+	hdr.bh_ffcounter = *ffcount;
+#endif
 	hdr.bh_datalen = pktlen;
@@ -2541,2 +2633,60 @@
 
+///*
+// * Show or change the per bpf_if or system wide default timestamp configuration.
+// */
+//static int
+//bpf_tscfg_sysctl_handler(SYSCTL_HANDLER_ARGS)
+//{
+//	char tstype_name[16];
+//	struct bpf_if *bp;
+//	int error, tstype;
+//
+//	bp = (struct bpf_if *)arg1;
+//
+//	if (req->newptr == NULL) {
+//		/*
+//		 * Return the name of the BPF interface's timestamp setting, or
+//		 * the system wide default if bp is NULL.
+//		 */
+//		strlcpy(tstype_name,
+//		    bpfiftstypes[bp ? bp->tstype : bpf_default_tstype],
+//		    sizeof(tstype_name));
+//		error = sysctl_handle_string(oidp, tstype_name,
+//		    sizeof(tstype_name), req);
+//	} else {
+//		/*
+//		 * Change the timestamp configuration for this BPF interface or
+//		 * the system wide default setting.
+//		 */
+//		error = EINVAL;
+//		for (tstype = 0; tstype < NUM_BPFIFTSTYPES; tstype++) {
+//			if (strncmp((char *)req->newptr, bpfiftstypes[tstype],
+//			    strlen(bpfiftstypes[tstype])) == 0) {
+//				/* User specified type found in bpfiftstypes. */
+//				if (strcmp(oidp->oid_name, "default") == 0) {
+//					/*
+//					 * Don't allow BPF_TSTAMP_DEFAULT to be
+//					 * assigned to the
+//					 * "net.bpf.tscfg.default" OID.
+//					 */
+//					if (tstype != BPF_TSTAMP_DEFAULT) {
+//						bpf_default_tstype = tstype;
+//						error = 0;
+//					}
+//				} else {
+//					/*
+//					 * Valid tstype for
+//					 * "net.bpf.tscfg.<iface>" OID.
+//					 */
+//					bp->tstype = tstype;
+//					error = 0;
+//				}
+//				break;
+//			}
+//		}
+//	}
+//
+//	return (error);
+//}
+
 /*
@@ -2567,2 +2717,13 @@
 
+//	bp->tscfgoid = SYSCTL_ADD_PROC(NULL,
+//	    SYSCTL_STATIC_CHILDREN(_net_bpf_tscfg), OID_AUTO, ifp->if_xname,
+//	    CTLTYPE_STRING | CTLFLAG_RW, bp, sizeof(bp),
+//	    bpf_tscfg_sysctl_handler, "A",
+//	    "Interface BPF timestamp configuration");
+//	if (bp->tscfgoid == NULL) {
+//		free(bp, M_BPF);
+//		panic("bpfattach tscfgoid");
+//	}
+//
+//	bp->tstype = BPF_TSTAMP_DEFAULT;
 	LIST_INIT(&bp->bif_dlist);
@@ -2707,3 +2868,3 @@
 		LIST_REMOVE(bp, bif_next);
-
+        
 		rw_destroy(&bp->bif_lock);
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.h /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.h
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/bpf.h	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/bpf.h	2019-11-27 15:18:40.000000000 +1100
@@ -9,2 +9,5 @@
  *
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
+ *
  * Redistribution and use in source and binary forms, with or without
@@ -42,2 +45,4 @@
 
+#include <sys/_ffcounter.h>
+
 /* BSD style release date */
@@ -161,28 +166,45 @@
 
-/* Time stamping functions */
-#define	BPF_T_MICROTIME		0x0000
+/* Time stamping flags */
+// FORMAT flags 	[ mutually exclusive, not to be ORed ]
+#define	BPF_T_MICROTIME	0x0000
 #define	BPF_T_NANOTIME		0x0001
 #define	BPF_T_BINTIME		0x0002
-#define	BPF_T_NONE		0x0003
+#define	BPF_T_NONE			0x0003	// relates to ts only, FFRAW independent
 #define	BPF_T_FORMAT_MASK	0x0003
-#define	BPF_T_NORMAL		0x0000
-#define	BPF_T_FAST		0x0100
-#define	BPF_T_MONOTONIC		0x0200
-#define	BPF_T_MONOTONIC_FAST	(BPF_T_FAST | BPF_T_MONOTONIC)
-#define	BPF_T_FLAG_MASK		0x0300
-#define	BPF_T_FORMAT(t)		((t) & BPF_T_FORMAT_MASK)
-#define	BPF_T_FLAG(t)		((t) & BPF_T_FLAG_MASK)
-#define	BPF_T_VALID(t)						\
-    ((t) == BPF_T_NONE || (BPF_T_FORMAT(t) != BPF_T_NONE &&	\
-    ((t) & ~(BPF_T_FORMAT_MASK | BPF_T_FLAG_MASK)) == 0))
-
-#define	BPF_T_MICROTIME_FAST		(BPF_T_MICROTIME | BPF_T_FAST)
-#define	BPF_T_NANOTIME_FAST		(BPF_T_NANOTIME | BPF_T_FAST)
-#define	BPF_T_BINTIME_FAST		(BPF_T_BINTIME | BPF_T_FAST)
-#define	BPF_T_MICROTIME_MONOTONIC	(BPF_T_MICROTIME | BPF_T_MONOTONIC)
-#define	BPF_T_NANOTIME_MONOTONIC	(BPF_T_NANOTIME | BPF_T_MONOTONIC)
-#define	BPF_T_BINTIME_MONOTONIC		(BPF_T_BINTIME | BPF_T_MONOTONIC)
-#define	BPF_T_MICROTIME_MONOTONIC_FAST	(BPF_T_MICROTIME | BPF_T_MONOTONIC_FAST)
-#define	BPF_T_NANOTIME_MONOTONIC_FAST	(BPF_T_NANOTIME | BPF_T_MONOTONIC_FAST)
-#define	BPF_T_BINTIME_MONOTONIC_FAST	(BPF_T_BINTIME | BPF_T_MONOTONIC_FAST)
+// FFRAW flag
+#define	BPF_T_NOFFC			0x0000   // no FFcount
+#define	BPF_T_FFC			0x0010   // want FFcount
+#define	BPF_T_FFRAW_MASK	0x0010
+// FLAVOR flags   [ can view bits as ORable flags ]
+#define	BPF_T_NORMAL		0x0000	// UTC, !FAST
+#define	BPF_T_FAST			0x0100   // UTC,  FAST
+#define	BPF_T_MONOTONIC	0x0200	// UPTIME, !FAST
+#define	BPF_T_MONOTONIC_FAST	0x0300// UPTIME,  FAST
+#define	BPF_T_FLAVOR_MASK	0x0300
+// CLOCK flags   [ mutually exclusive, not to be ORed ]
+#define	BPF_T_SYSCLOCK		0x0000	// read current sysclock
+#define	BPF_T_FBCLOCK		0x1000   // read FB
+#define	BPF_T_FFCLOCK		0x2000   // read mono FF (standard reads are mono)
+#define	BPF_T_FFNATIVECLOCK	0x3000// read native FF
+#define	BPF_T_CLOCK_MASK	0x3000
+
+// Extract FORMAT, FFRAW, FLAVOR, CLOCK  bits
+#define	BPF_T_FORMAT(t)	((t) & BPF_T_FORMAT_MASK)
+#define	BPF_T_FFRAW(t)		((t) & BPF_T_FFRAW_MASK)
+#define	BPF_T_FLAVOR(t)	((t) & BPF_T_FLAVOR_MASK)
+#define	BPF_T_CLOCK(t)		((t) & BPF_T_CLOCK_MASK)
+
+// Used to vet descriptor passed to BPF via BIOCSTSTAMP ioctl
+// In KV3, all components are independent, and either always meaningful, or
+// not acted on if not meaningful (eg if !FFCLOCK, or value of CLOCK if requesting
+// BPF_T_NONE   Hence checks reduce to ensuring no bits in undefined positions.
+// and not ask for a FF clock that doesnt exist.
+#ifdef FFCLOCK
+#define	BPF_T_VALID(t)	( ((t) & ~(BPF_T_FORMAT_MASK | BPF_T_FFRAW_MASK | \
+											  BPF_T_FLAVOR_MASK | BPF_T_CLOCK_MASK)) == 0 )
+#else
+#define	BPF_T_VALID(t)	( ((t) & ~(BPF_T_FORMAT_MASK | BPF_T_FFRAW_MASK | \
+											  BPF_T_FLAVOR_MASK | BPF_T_CLOCK_MASK)) == 0 \
+									&& BPF_T_FORMAT(t)<=BPF_T_FBCLOCK )
+#endif
 
@@ -197,2 +219,3 @@
 	struct bpf_ts	bh_tstamp;	/* time stamp */
+	ffcounter	bh_ffcounter;	/* feed-forward counter stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
@@ -205,2 +228,3 @@
 	struct timeval	bh_tstamp;	/* time stamp */
+	ffcounter	bh_ffcounter;	/* feed-forward counter stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
@@ -215,2 +239,9 @@
 
+#ifdef FFCLOCK
+/*
+ * Feed-forward counter accessor.
+ */
+#define	BP
+#endif
+
 /*
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_ffclock.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_ffclock.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_ffclock.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_ffclock.c	2019-11-27 15:18:40.000000000 +1100
@@ -4,4 +4,4 @@
  *
- * This software was developed by Julien Ridoux at the University of Melbourne
- * under sponsorship from the FreeBSD Foundation.
+ * This software was developed by Julien Ridoux and Darryl Veitch at the 
+ * University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -30,3 +30,3 @@
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: releng/11.2/sys/kern/kern_ffclock.c 298310 2016-04-19 23:48:27Z pfg $");
+__FBSDID("$FreeBSD$");
 
@@ -92,3 +92,3 @@
 	 * Leap second adjustment. Total as seen by synchronisation algorithm
-	 * since it started. cest.leapsec_next is the ffcounter prediction of
+	 * since it started. cest.leapsec_expected is the ffcounter prediction of
 	 * when the next leapsecond occurs.
@@ -96,5 +96,5 @@
 	if ((flags & FFCLOCK_LEAPSEC) == FFCLOCK_LEAPSEC) {
-		bt->sec -= cest.leapsec_total;
-		if (ffc > cest.leapsec_next)
-			bt->sec -= cest.leapsec;
+		bt->sec -= cest.leapsec_total;	// subtracting means including leaps
+		if (cest.leapsec_expected != 0 && ffc > cest.leapsec_expected)
+			bt->sec -= cest.leapsec_next;
 	}
@@ -110,8 +110,4 @@
 		ffclock_convert_diff(ffdelta_error, error_bound);
-		/* 18446744073709 = int(2^64/1e12), err_bound_rate in [ps/s] */
-		bintime_mul(error_bound, cest.errb_rate *
-		    (uint64_t)18446744073709LL);
-		/* 18446744073 = int(2^64 / 1e9), since err_abs in [ns] */
-		bintime_addx(error_bound, cest.errb_abs *
-		    (uint64_t)18446744073LL);
+		bintime_mul(error_bound, cest.errb_rate * PS_IN_BINFRAC);	// errb_rate ps/s
+		bintime_addx(error_bound, cest.errb_abs * NS_IN_BINFRAC);	// errb_abs [ns]
 	}
@@ -144,4 +140,3 @@
 		ffclock_convert_diff(ffdelta, error_bound);
-		/* 18446744073709 = int(2^64/1e12), err_bound_rate in [ps/s] */
-		bintime_mul(error_bound, err_rate * (uint64_t)18446744073709LL);
+		bintime_mul(error_bound, err_rate * PS_IN_BINFRAC);	// err_rate in [ps/s]
 	}
@@ -164,3 +159,3 @@
 
-static int ffclock_version = 2;
+static int ffclock_version = 3;
 SYSCTL_INT(_kern_sysclock_ffclock, OID_AUTO, version, CTLFLAG_RD,
@@ -206,3 +201,6 @@
 	int error;
-	int clk;
+	int clk=0;
+	struct bintime bt;
+	ffcounter ffcount;
+	static int ccc = 0;
 
@@ -211,2 +209,6 @@
 	error = sysctl_handle_string(oidp, newclock, sizeof(newclock), req);
+	
+	ffclock_last_tick(&ffcount, &bt, 0);
+	printf(" %d\t Callback sys_active start  %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   	ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
 
@@ -214,9 +216,11 @@
 	if (error != 0 || req->newptr == NULL)
-		goto done;
+		return (error);
 
-	/* Change the active sysclock to the user specified one: */
+	/* Change the active sysclock to the user specified one */
 	error = EINVAL;
 	for (clk = 0; clk < NUM_SYSCLOCKS; clk++) {
-		if (strncmp(newclock, sysclocks[clk],
-		    MAX_SYSCLOCK_NAME_LEN - 1)) {
+		if (strncmp(newclock, sysclocks[clk], MAX_SYSCLOCK_NAME_LEN - 1)) {
+			ffclock_last_tick(&ffcount, &bt, 0);
+			printf(" %d\t                    inloop %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   			ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
 			continue;
@@ -225,5 +229,11 @@
 		error = 0;
+		ffclock_last_tick(&ffcount, &bt, 0);
+		printf(" %d\t                    afloop %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   		ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
 		break;
 	}
-done:
+	ffclock_last_tick(&ffcount, &bt, 0);
+	printf(" %d\t                    atend  %llu: clk=%d sysclock_active= %d, newclock= %s  error= %d\n",
+   	ccc++, (long long unsigned)ffcount,  clk, sysclock_active, newclock, error);
+	
 	return (error);
@@ -246,3 +256,2 @@
 {
-
 	ffclock_abstime(NULL, bt, NULL, FFCLOCK_LERP | FFCLOCK_LEAPSEC);
@@ -271,3 +280,2 @@
 {
-
 	ffclock_abstime(NULL, bt, NULL,
@@ -429,4 +437,8 @@
 	memcpy(&ffclock_estimate, &cest, sizeof(struct ffclock_estimate));
-	ffclock_updated++;
+	if (ffclock_updated == INT8_MAX)	// reset not yet processed by ffclock_windup
+		ffclock_updated = 1;
+	else
+		ffclock_updated++;
 	mtx_unlock(&ffclock_mtx);
+	
 	return (error);
@@ -463,3 +475,2 @@
 {
-
 	return (ENOSYS);
@@ -470,3 +481,2 @@
 {
-
 	return (ENOSYS);
@@ -477,3 +487,2 @@
 {
-
 	return (ENOSYS);
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_tc.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_tc.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/kern_tc.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/kern_tc.c	2019-11-27 15:18:40.000000000 +1100
@@ -11,4 +11,4 @@
  *
- * Portions of this software were developed by Julien Ridoux at the University
- * of Melbourne under sponsorship from the FreeBSD Foundation.
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -546,2 +546,3 @@
 	struct bintime		tick_time_lerp;
+	struct bintime		tick_error;
 	ffcounter		tick_ffcount;
@@ -583,3 +584,3 @@
 void
-ffclock_reset_clock(struct timespec *ts)
+ffclock_setto_rtc(struct timespec *ts)
 {
@@ -594,3 +595,3 @@
 	ffclock_read_counter(&cest.update_ffcount);
-	cest.leapsec_next = 0;
+	cest.next_expected = 0;
 	cest.period = ((1ULL << 63) / tc->tc_frequency) << 1;
@@ -599,4 +600,5 @@
 	cest.status = FFCLOCK_STA_UNSYNC;
+	cest.leapsec_expected = 0;
 	cest.leapsec_total = 0;
-	cest.leapsec = 0;
+	cest.leapsec_next = 0;
 
@@ -607,5 +609,6 @@
 
-	printf("ffclock reset: %s (%llu Hz), time = %ld.%09lu\n", tc->tc_name,
-	    (unsigned long long)tc->tc_frequency, (long)ts->tv_sec,
-	    (unsigned long)ts->tv_nsec);
+	printf("ffclock_setto_rtc: at vcount = %llu:  %s (%llu Hz), time = %ld.%09lu\n",
+		(unsigned long long)cest.update_ffcount, tc->tc_name,
+		(unsigned long long)tc->tc_frequency, (long)ts->tv_sec,
+		(unsigned long)ts->tv_nsec);
 }
@@ -640,9 +643,61 @@
 
+
+/* Function to print out FFtimehands tick state neatly */
+static void
+printout_FFtick(struct fftimehands *ffth)
+{
+	struct ffclock_estimate *cest;
+
+	cest = &ffth->cest; 	// access FFclock data member
+	printf("-------------------------------------------------------------\n");
+	printf("Pretty printing fftimehands tick data.\n");
+	printf("cest: \n");
+	printf("*    period %llu\n",
+		(unsigned long long)cest->period);
+	printf("*    update_time: %llu.%llu [bintime]\t\t status: 0x%04X\n",
+		(unsigned long long)cest->update_time.sec,
+		(unsigned long long)cest->update_time.frac, cest->status);
+	printf("*    update_ffcount: %llu  next_expected: %llu      (u_diff: %llu)\n",
+		(unsigned long long)cest->update_ffcount,
+		(unsigned long long)cest->next_expected,
+		(unsigned long long)(cest->next_expected - cest->update_ffcount));
+	printf("*    errb_{abs,rate} = %lu  %lu\n",
+		(unsigned long)cest->errb_abs, (unsigned long)cest->errb_rate);
+	printf("*    leapsec_{expected,total,next}:  %llu  %d  %d\n",
+		(unsigned long long)cest->leapsec_expected,
+		cest->leapsec_total, cest->leapsec_next);
+	printf("-------------------------------------------------------------\n");
+	
+	printf("   tick_time:      %llu.%llu [bintime]\n",
+		(unsigned long long)ffth->tick_time.sec,
+		(unsigned long long)ffth->tick_time.frac);
+	printf("   tick_time_lerp: %llu.%llu [bintime]\n",
+		(unsigned long long)ffth->tick_time_lerp.sec,
+		(unsigned long long)ffth->tick_time_lerp.frac);
+	printf("   tick_error: %llu.%llu [bintime]\n",
+		(unsigned long long)ffth->tick_error.sec,
+		(unsigned long long)ffth->tick_error.frac);
+	
+	printf("   tick_ffcount: %llu \n", (unsigned long long)ffth->tick_ffcount);
+	printf("   period_lerp %llu (u_diff: %llu %llu)\n",
+		(unsigned long long)ffth->period_lerp,
+		(unsigned long long)(ffth->period_lerp - cest->period),
+		(unsigned long long)(cest->period - ffth->period_lerp));
+	printf("   gen %u\n", (unsigned int)ffth->gen);
+
+	printf("-------------------------------------------------------------\n\n");
+}
+
+
 /*
- * Update the fftimehands.
- * Push the tick ffcount and time(s) forward based on current clock estimate.
- * The conversion from ffcounter to bintime relies on the difference clock
- * principle, whose accuracy relies on computing small time intervals. If a new
- * clock estimate has been passed by the synchronisation daemon, make it
- * current, and compute the linear interpolation for monotonic time if needed.
+ * Update the fftimehands. The updated tick state is based on the previous tick if
+ * there has been no actionable update in the FFclock parameters during the current
+ * tick (ffclock_updated <= 0), and both the native and monotonic FFclocks advance
+ * linearly. Otherwise it is based off the updated parameters and
+ * the time of the update. The native FFclock will then jump, the monotonic clock will
+ * not (except under special conditions).  The linear interpolation parameters of the
+ * monotonic FFclock ({tick_time,period}_lerp) are recomputed for the new tick.
+ *
+ * The instant defining the start of the new tick is the  delta=tc_delta call
+ *	from tc_windup. This is simply mirrored here in the FF counter `read'.
  */
@@ -656,10 +711,14 @@
 	uint64_t frac;
-	unsigned int polling;
+	u_int secs_to_nextupdate;
 	uint8_t forward_jump, ogen;
 
-	/*
-	 * Pick the next timehand, copy current ffclock estimates and move tick
-	 * times and counter forward.
-	 */
+	/* verbosity control */
+	struct bintime bttest;
+	static u_int ccc = 0;
+	static u_int	 watch = 0;
+   int updatedcopy = ffclock_updated;
+	
 	forward_jump = 0;
+	
+	/* Prepare next fftimehand where tick state will be updated */
 	ffth = fftimehands->next;
@@ -668,55 +727,103 @@
 	cest = &ffth->cest;
-	bcopy(&fftimehands->cest, cest, sizeof(struct ffclock_estimate));
-	ffdelta = (ffcounter)delta;
-	ffth->period_lerp = fftimehands->period_lerp;
-
-	ffth->tick_time = fftimehands->tick_time;
-	ffclock_convert_delta(ffdelta, cest->period, &bt);
-	bintime_add(&ffth->tick_time, &bt);
-
-	ffth->tick_time_lerp = fftimehands->tick_time_lerp;
-	ffclock_convert_delta(ffdelta, ffth->period_lerp, &bt);
-	bintime_add(&ffth->tick_time_lerp, &bt);
 
+	/* Move FF counter forward to existing tick start */
+	ffdelta = (ffcounter)delta;
 	ffth->tick_ffcount = fftimehands->tick_ffcount + ffdelta;
 
-	/*
-	 * Assess the status of the clock, if the last update is too old, it is
-	 * likely the synchronisation daemon is dead and the clock is free
-	 * running.
+	/* No acceptable update in FFclock parameters to process.
+	 * Tick state update based on copy or simple projection from previous tick.
 	 */
-	if (ffclock_updated == 0) {
-		ffdelta = ffth->tick_ffcount - cest->update_ffcount;
+	if (ffclock_updated <= 0) {
+		
+		/* Update native FFclock members {cest, tick_time, tick_error} */
+		bcopy(&fftimehands->cest, cest, sizeof(struct ffclock_estimate));
+		ffth->tick_time   = fftimehands->tick_time;
 		ffclock_convert_delta(ffdelta, cest->period, &bt);
-		if (bt.sec > 2 * FFCLOCK_SKM_SCALE)
-			ffclock_status |= FFCLOCK_STA_UNSYNC;
+		bttest.sec = bt.sec;
+		bttest.frac = bt.frac;
+		bintime_add(&ffth->tick_time, &bt);						// bt not changed, reuse
+		if (!bintime_cmp(&bt,&bttest,=)) {
+			printf(" %d\t ffwindup  %llu:  bt found to have changed! \n",
+   					ccc, (long long unsigned)fftimehands->tick_ffcount);
+			printf(" \t\t  old bt: %llu.%llu\n",
+					(unsigned long long)bttest.sec, (unsigned long long)bttest.frac);
+			printf(" \t\t  new bt: %llu.%llu\n",
+					(unsigned long long)bt.sec, 		(unsigned long long)bt.frac);
+			if (!watch) watch = 1;	// activate verbosity watching
+		}
+		bintime_mul(&bt, cest->errb_rate * PS_IN_BINFRAC);	// errb_rate in [ps/s]
+		bintime_add(&ffth->tick_error, &bt);
+
+		/* Update mono FFclock members {period_lerp, tick_time_lerp} */
+		ffth->period_lerp = fftimehands->period_lerp;
+		ffth->tick_time_lerp = fftimehands->tick_time_lerp;
+		ffclock_convert_delta(ffdelta, ffth->period_lerp, &bt);
+		bintime_add(&ffth->tick_time_lerp, &bt);
+
+		/* Check if the clock status should be set to unsynchronized.
+		 * Assessment based on age of last/current update, and the daemon's estimate
+		 * of the wait to the next update, converted to an interval in seconds.
+		 * If the daemon's UNSYNC status is deemed too stale, it is over-ridden.
+		 */
+		if (ffclock_updated == 0) {
+			if (cest->next_expected < cest->update_ffcount)	// no daemon updates yet
+				secs_to_nextupdate = 0;
+			else {
+				ffdelta = cest->next_expected - cest->update_ffcount;
+				ffclock_convert_delta(ffdelta, cest->period, &bt);
+				secs_to_nextupdate = (u_int)bt.sec;	// expected time to next update
+				if (secs_to_nextupdate==0) secs_to_nextupdate = 1;
+			}
+			ffdelta = ffth->tick_ffcount - cest->update_ffcount;
+			ffclock_convert_delta(ffdelta, cest->period, &bt); // time since update
+			if (bt.sec > 3 * FFCLOCK_SKM_SCALE && bt.sec > 3 * secs_to_nextupdate)
+				ffclock_status |= FFCLOCK_STA_UNSYNC;
+		}
+		
 	}
 
-	/*
-	 * If available, grab updated clock estimates and make them current.
-	 * Recompute time at this tick using the updated estimates. The clock
-	 * estimates passed the feed-forward synchronisation daemon may result
-	 * in time conversion that is not monotonically increasing (just after
-	 * the update). time_lerp is a particular linear interpolation over the
-	 * synchronisation algo polling period that ensures monotonicity for the
-	 * clock ids requesting it.
+	/* Flag event where FFclock update entered next tick. Should be very rare. */
+	if (ffclock_estimate.update_ffcount > ffth->tick_ffcount) {
+		printf("ffclock_windup: at vcount = %llu, ffclock update slipped into "
+		       "next tick, will process on next call. \n",
+				(unsigned long long)ffth->tick_ffcount);
+		if (!watch) watch = 1;	// activate verbosity watching
+	}
+	
+	/* An update in FFclock parameters is available in this tick.
+	 * Generate the new tick state based on this, projected from the update time.
 	 */
-	if (ffclock_updated > 0) {
+	if (ffclock_updated > 0 &&     // if an update occurred in current tick
+	    ffclock_estimate.update_ffcount < ffth->tick_ffcount) {
+		
+		/* Update native FFclock members {cest, tick_time, tick_error} */
 		bcopy(&ffclock_estimate, cest, sizeof(struct ffclock_estimate));
-		ffdelta = ffth->tick_ffcount - cest->update_ffcount;
+		ffdelta = ffth->tick_ffcount - cest->update_ffcount; // time since update
 		ffth->tick_time = cest->update_time;
 		ffclock_convert_delta(ffdelta, cest->period, &bt);
-		bintime_add(&ffth->tick_time, &bt);
-
-		/* ffclock_reset sets ffclock_updated to INT8_MAX */
-		if (ffclock_updated == INT8_MAX)
+		bintime_add(&ffth->tick_time, &bt);						// bt not changed, reuse
+		bintime_mul(&bt, cest->errb_rate * PS_IN_BINFRAC);	// errb_rate in [ps/s]
+		bintime_addx(&bt, cest->errb_abs * NS_IN_BINFRAC);	// errb_abs in [ns]
+		ffth->tick_error = bt;
+
+		/* Update mono FFclock member tick_time_lerp, standard case.
+		 *   ffclock_updated by ffclock_setto_rtc :  re-initialize
+		 *   ffclock_updated by daemon :             ensure continuity across ticks
+		 */
+		if (ffclock_updated == INT8_MAX)	{	// update set by ffclock_setto_rtc
 			ffth->tick_time_lerp = ffth->tick_time;
-
-		if (bintime_cmp(&ffth->tick_time, &ffth->tick_time_lerp, >))
-			forward_jump = 1;
-		else
-			forward_jump = 0;
-
+			if (!watch) watch = 1;	// activate verbosity watching
+		} else {
+			ffth->tick_time_lerp = fftimehands->tick_time_lerp;
+			ffclock_convert_delta((ffcounter)delta, fftimehands->period_lerp, &bt);
+			bintime_add(&ffth->tick_time_lerp, &bt);
+		}
+		
+		/* Record direction of jump between monoFFclock and FFclock at tick start */
+      if (bintime_cmp(&ffth->tick_time, &ffth->tick_time_lerp, >))
+			forward_jump = 1;		// else = 0
+		
+		/* Record magnitude of jump */
 		bintime_clear(&gap_lerp);
-		if (forward_jump) {
+		if (forward_jump) {		// monoFFclock < FFclock
 			gap_lerp = ffth->tick_time;
@@ -727,12 +834,9 @@
 		}
-
-		/*
-		 * The reset from the RTC clock may be far from accurate, and
-		 * reducing the gap between real time and interpolated time
-		 * could take a very long time if the interpolated clock insists
-		 * on strict monotonicity. The clock is reset under very strict
-		 * conditions (kernel time is known to be wrong and
-		 * synchronization daemon has been restarted recently.
-		 * ffclock_boottime absorbs the jump to ensure boot time is
-		 * correct and uptime functions stay consistent.
+		
+		/* Update mono FFclock member tick_time_lerp, exceptional case.
+		 * Break monotonicity by allowing mono FFclock to jump to meet native FFclock
+		 * Only occurs under tight conditions to prevent a poor mono FFclock
+		 * initialization from taking a very long time to catch up to FFclock.
+		 * Also, absorb the jump into ffclock_boottime to ensure continuity of boot
+		 * uptime functions.
 		 */
@@ -746,24 +850,38 @@
 			ffth->tick_time_lerp = ffth->tick_time;
-			bintime_clear(&gap_lerp);
+			bintime_clear(&gap_lerp); // signal to period_lerp algo that nothing to do
+			printf("** ffwindup:  Jumping monotonic FFclock\n" );
+			if (!watch) watch = 1;	// activate verbosity watching
 		}
 
-		ffclock_status = cest->status;
-		ffth->period_lerp = cest->period;
-
-		/*
-		 * Compute corrected period used for the linear interpolation of
-		 * time. The rate of linear interpolation is capped to 5000PPM
-		 * (5ms/s).
+		
+		/* Update mono FFclock member period_lerp
+		 * The goal of the monoFF algorithm is to reduce gap between monoFF and the
+		 * native FF to zero by the next FFclock update. The reduction uses linear
+		 * interpolation via selecting period_lerp.  To ensure rate quality,
+		 * |period_lerp - period| is capped to 5000PPM (5ms/s).
+		 * If there is no gap, the clocks will agree throughout the new tick.
 		 */
-		if (bintime_isset(&gap_lerp)) {
-			ffdelta = cest->update_ffcount;
-			ffdelta -= fftimehands->cest.update_ffcount;
+		ffth->period_lerp = cest->period;   // re-initialize
+
+		/* Keep default if no (or negligible) gap or no daemon updates yet */
+		if (bintime_isset(&gap_lerp) && cest->next_expected > 0) {
+
+			/* Calculate cap */
+			ffdelta = cest->next_expected - cest->update_ffcount;
 			ffclock_convert_delta(ffdelta, cest->period, &bt);
-			polling = bt.sec;
+			secs_to_nextupdate = (u_int)bt.sec;		// time to next update
+			if (secs_to_nextupdate==0) secs_to_nextupdate = 1;
 			bt.sec = 0;
-			bt.frac = 5000000 * (uint64_t)18446744073LL;
-			bintime_mul(&bt, polling);
-			if (bintime_cmp(&gap_lerp, &bt, >))
-				gap_lerp = bt;
-
+			bt.frac = 5000000 * NS_IN_BINFRAC;
+			bintime_mul(&bt, secs_to_nextupdate);
+			/* Determine the amount of gap to close over the next update interval */
+			if (bintime_cmp(&gap_lerp, &bt, >)) {
+				printf(" %u **  capping  gap_lerp  from %llu.%llu to %llu.%llu  [bintime]\n", ccc,
+					(long long unsigned)gap_lerp.sec,
+					(long long unsigned)gap_lerp.frac,
+					(long long unsigned)bt.sec,
+					(long long unsigned)bt.frac );
+				gap_lerp = bt;		// gap_lerp = min(gap_lerp, bt)
+			}
+	
 			/* Approximate 1 sec by 1-(1/2^64) to ease arithmetic */
@@ -774,3 +892,3 @@
 			}
-			frac += gap_lerp.frac / ffdelta;
+			frac += gap_lerp.frac / ffdelta;		// portion of gap per cycle
 
@@ -780,6 +898,17 @@
 				ffth->period_lerp -= frac;
+			
+//		   if (frac==0) {  // will be inactive if gap too small
+//				printf(" %u **  warning, is a gap yet period_lerp not changed\n", ccc);
+//				printf("    **  gap_lerp.frac %llu  ,  ffdelta = %llu  [bintime]\n",
+//					(long long unsigned)gap_lerp.frac,
+//					(long long unsigned)ffdelta );
+//				if (!watch) watch = 1;	// activate verbosity watching
+//			}
 		}
 
-		ffclock_updated = 0;
+		ffclock_status = cest->status;
+		ffclock_updated = 0;		// signal that latest update processed
 	}
+	
+	/* Bump generation of new tick, avoiding the reserved 0 value */
 	if (++ogen == 0)
@@ -787,3 +916,16 @@
 	ffth->gen = ogen;
+	
+	if ( watch ) {
+		// if ( (fftimehands->tick_ffcount) < 3000*timehands->th_counter->tc_frequency && ccc<20) { // <10sec
+		printf(" %u\t ffwindup:  ffclock_updated = %d  Tick start = %llu \n",
+				 ccc++, updatedcopy, (long long unsigned)fftimehands->tick_ffcount );
+		printout_FFtick(fftimehands);		// current
+		printf("   UPDATED TO --->\n");
+		printout_FFtick(ffth);				// updated
+		watch++;
+		if (watch>=3) watch = 0; 	//	switch watch off after context interval
+	}
+	
 	fftimehands = ffth;
+	
 }
@@ -815,2 +957,3 @@
 	bcopy(&(fftimehands->cest), cest, sizeof(struct ffclock_estimate));
+	cest->next_expected = 0;
 	cest->period = ((1ULL << 63) / tc->tc_frequency ) << 1;
@@ -819,2 +962,5 @@
 	cest->status |= FFCLOCK_STA_UNSYNC;
+	cest->leapsec_expected = 0;
+	cest->leapsec_total = 0;
+	cest->leapsec_next = 0;
 
@@ -826,4 +972,7 @@
 	/* Do not lock but ignore next update from synchronization daemon. */
-	ffclock_updated--;
-
+	if (ffclock_updated == INT8_MAX)	// reset not yet processed by ffclock_windup
+		ffclock_updated = -1;
+	else
+		ffclock_updated--;
+	
 	if (++ogen == 0)
@@ -832,2 +981,6 @@
 	fftimehands = ffth;
+	
+	printf("ffclock_change_tc: at tick_ffcount = %llu, to  %s (%llu Hz)\n",
+		(unsigned long long)ffth->tick_ffcount, tc->tc_name,
+		(unsigned long long)tc->tc_frequency);
 }
@@ -1073,3 +1226,2 @@
 #ifdef FFCLOCK
-	ffcounter ffcount;
 	struct fftimehands *ffth;
@@ -1107,8 +1259,7 @@
 	/* Record feedback clock status and error. */
-	clock_snap->fb_info.status = time_status;
+	fbi->status = time_status;
 	/* XXX: Very crude estimate of feedback clock error. */
-	bt.sec = time_esterror / 1000000;
-	bt.frac = ((time_esterror - bt.sec) * 1000000) *
-	    (uint64_t)18446744073709ULL;
-	clock_snap->fb_info.error = bt;
+	bt.sec = time_esterror / 1000000;			// time_esterror is in mus
+	bt.frac = (time_esterror - bt.sec * 1000000) * MUS_IN_BINFRAC;
+	fbi->error = bt;
 
@@ -1118,16 +1269,17 @@
 
-	/* Record feed-forward clock leap second adjustment. */
+	/* Precalculate total leap second adjustment appropriate to this ffcount.
+	 * Includes total leaps so far and impending leap ffcount may have surpassed.
+	 */
 	ffi->leapsec_adjustment = cest.leapsec_total;
-	if (clock_snap->ffcount > cest.leapsec_next)
-		ffi->leapsec_adjustment -= cest.leapsec;
+	if (cest.leapsec_expected != 0 && clock_snap->ffcount > cest.leapsec_expected)
+		ffi->leapsec_adjustment += cest.leapsec_next;
 
 	/* Record feed-forward clock status and error. */
-	clock_snap->ff_info.status = cest.status;
-	ffcount = clock_snap->ffcount - cest.update_ffcount;
-	ffclock_convert_delta(ffcount, cest.period, &bt);
-	/* 18446744073709 = int(2^64/1e12), err_bound_rate in [ps/s]. */
-	bintime_mul(&bt, cest.errb_rate * (uint64_t)18446744073709ULL);
-	/* 18446744073 = int(2^64 / 1e9), since err_abs in [ns]. */
-	bintime_addx(&bt, cest.errb_abs * (uint64_t)18446744073ULL);
-	clock_snap->ff_info.error = bt;
+	ffi->status = cest.status;
+	ffi->error = ffth->tick_error;
+	if (!fast) {
+		ffclock_convert_delta((ffcounter)delta, cest.period, &bt);
+		bintime_mul(&bt, cest.errb_rate * PS_IN_BINFRAC);	// errb_rate in [ps/s]
+		bintime_add(&ffi->error, &bt);
+	}
 #endif
@@ -1138,2 +1290,3 @@
  * clock source and flags.
+ * Note:  Leap and Uptime flags should never be used together.
  */
@@ -1141,3 +1294,3 @@
 sysclock_snap2bintime(struct sysclock_snap *cs, struct bintime *bt,
-    int whichclock, uint32_t flags)
+    int whichclock, int wantFast, int wantUptime, int wantFFlerp)
 {
@@ -1154,6 +1307,7 @@
 		/* If snapshot was created with !fast, delta will be >0. */
-		if (cs->delta > 0)
+		if (!wantFast && cs->delta > 0)
 			bintime_addx(bt, cs->fb_info.th_scale * cs->delta);
 
-		if ((flags & FBCLOCK_UPTIME) == 0) {
+		/* Native FBclock is Uptime, need to adjust if want UTC */
+		if (!wantUptime) {
 			getboottimebin(&boottimebin_x);
@@ -1164,3 +1318,3 @@
 	case SYSCLOCK_FFWD:
-		if (flags & FFCLOCK_LERP) {
+		if (wantFFlerp) {
 			*bt = cs->ff_info.tick_time_lerp;
@@ -1173,4 +1327,4 @@
 		/* If snapshot was created with !fast, delta will be >0. */
-		if (cs->delta > 0) {
-			ffclock_convert_delta(cs->delta, period, &bt2);
+		if (!wantFast && cs->delta > 0) {
+			ffclock_convert_delta((ffcounter)cs->delta, period, &bt2);
 			bintime_add(bt, &bt2);
@@ -1178,9 +1332,8 @@
 
-		/* Leap second adjustment. */
-		if (flags & FFCLOCK_LEAPSEC)
+		/* Add appropriate constant to create Uptime or UTC flavor */
+		if (wantUptime) // Uptime
+			bintime_sub(bt, &ffclock_boottime);
+		else				 // UTC
 			bt->sec -= cs->ff_info.leapsec_adjustment;
 
-		/* Boot time adjustment, for uptime/monotonic clocks. */
-		if (flags & FFCLOCK_UPTIME)
-			bintime_sub(bt, &ffclock_boottime);
 		break;
@@ -1487,4 +1640,8 @@
 	case SYSCLOCK_FFWD:
-		time_second = fftimehands->tick_time_lerp.sec;
-		time_uptime = fftimehands->tick_time_lerp.sec - ffclock_boottime.sec;
+		ffclock_getbintime(&bt);
+		time_second = bt.sec;
+		//time_second = fftimehands->tick_time_lerp.sec;   // wrong, leaps not added!
+		ffclock_getbinuptime(&bt);
+		time_uptime = bt.sec;
+		//time_uptime = fftimehands->tick_time_lerp.sec - ffclock_boottime.sec;
 		break;
@@ -1504,2 +1661,5 @@
 	int error;
+	struct bintime bt;
+	ffcounter ffcount;
+	static int ccc = 0;
 
@@ -1508,3 +1668,8 @@
 
+	ffclock_last_tick(&ffcount, &bt, 0);
+	//printf(" %d\t Callback tc_hardware start  %llu:  newname= %s \n",
+   //	ccc++, (long long unsigned)ffcount, newname);
+
 	error = sysctl_handle_string(oidp, &newname[0], sizeof(newname), req);
+	
 	if (error != 0 || req->newptr == NULL)
@@ -1519,2 +1684,4 @@
 
+		printf(" %d\t Callback tc_hardware start  %llu:  newname= %s  error= %d\n",
+   	ccc++, (long long unsigned)ffcount, newname, error);
 		/* Warm up new timecounter. */
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/subr_rtc.c /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/subr_rtc.c
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/subr_rtc.c	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/subr_rtc.c	2019-11-27 15:18:40.000000000 +1100
@@ -11,4 +11,4 @@
  *
- * Portions of this software were developed by Julien Ridoux at the University
- * of Melbourne under sponsorship from the FreeBSD Foundation.
+ * Portions of this software were developed by Julien Ridoux and Darryl Veitch
+ * at the University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -360,3 +360,3 @@
 #ifdef FFCLOCK
-		ffclock_reset_clock(&ts);
+		ffclock_setto_rtc(&ts);
 #endif
diff -U 1 --unidirectional-new-file /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/timeffc.h /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/timeffc.h
--- /Users/darryl/Papers/TSCclock/Programs/V4/OriginalSource_11.2/timeffc.h	2019-03-07 17:28:39.000000000 +1100
+++ /Users/darryl/Papers/TSCclock/Programs/V4/RADclock_mycurrent/kernel/freebsd/FreeBSD-11.2/CurrentSource/timeffc.h	2019-11-27 15:18:40.000000000 +1100
@@ -4,4 +4,4 @@
  *
- * This software was developed by Julien Ridoux at the University of Melbourne
- * under sponsorship from the FreeBSD Foundation.
+ * This software was developed by Julien Ridoux and Darryl Veitch at the 
+ * University of Melbourne under sponsorship from the FreeBSD Foundation.
  *
@@ -28,3 +28,3 @@
  *
- * $FreeBSD: releng/11.2/sys/sys/timeffc.h 331722 2018-03-29 02:50:57Z eadler $
+ * $FreeBSD$
  */
@@ -42,14 +42,23 @@
  */
-struct ffclock_estimate {
-	struct bintime	update_time;	/* Time of last estimates update. */
+struct ffclock_estimate
+{
+	struct bintime	update_time;	/* FF clock time of last update, ie Ca(tlast). */
 	ffcounter	update_ffcount;	/* Counter value at last update. */
-	ffcounter	leapsec_next;	/* Counter value of next leap second. */
-	uint64_t	period;		/* Estimate of counter period. */
-	uint32_t	errb_abs;	/* Bound on absolute clock error [ns]. */
-	uint32_t	errb_rate;	/* Bound on counter rate error [ps/s]. */
-	uint32_t	status;		/* Clock status. */
-	int16_t		leapsec_total;	/* All leap seconds seen so far. */
-	int8_t		leapsec;	/* Next leap second (in {-1,0,1}). */
+	ffcounter	next_expected;		/* Estimated time of next update [counter] */
+	ffcounter	leapsec_expected;	/* Estimated time of next leap second [counter]. */
+	uint64_t	period;				/* Estimate of current counter period  [2^-64 s] */
+	uint32_t	errb_abs;			/* Bound on absolute clock error [ns]. */
+	uint32_t	errb_rate;			/* Bound on relative counter period error [ps/s] */
+	uint32_t	status;				/* Clock status. */
+	int16_t		leapsec_total;		/* Sum of leap seconds seen since clock start. */
+	int8_t		leapsec_next;		/* Next leap second (in {-1,0,1}). */
 };
 
+/* Constants to hold errors and error rates in 64bit binary fraction fields */
+#define	MS_IN_BINFRAC	(uint64_t)18446744073709551ULL	// floor(2^64/1e3)
+#define	MUS_IN_BINFRAC	(uint64_t)18446744073709ULL		// floor(2^64/1e6)
+#define	NS_IN_BINFRAC	(uint64_t)18446744073ULL			// floor(2^64/1e9)
+#define	PS_IN_BINFRAC	(uint64_t)18446744ULL				// floor(2^64/1e12)
+
+
 #if __BSD_VISIBLE
@@ -86,2 +95,3 @@
  * converted into absolute time.
+ * The flags all set independent bits and so are OR-able.
  * {FB|FF}CLOCK_FAST:	Do not read the hardware counter, instead using the
@@ -96,3 +106,3 @@
 #define	FFCLOCK_LERP		0x00000002
-#define	FFCLOCK_LEAPSEC		0x00000004
+#define	FFCLOCK_LEAPSEC	0x00000004
 #define	FFCLOCK_UPTIME		0x00000008
@@ -100,3 +110,3 @@
 
-#define	FBCLOCK_FAST		0x00010000 /* Currently unused. */
+#define	FBCLOCK_FAST		0x00010000 /* Currently unused */
 #define	FBCLOCK_UPTIME		0x00020000
@@ -151,6 +161,6 @@
 int sysclock_snap2bintime(struct sysclock_snap *cs, struct bintime *bt,
-    int whichclock, uint32_t flags);
+    int whichclock, int wantFast, int wantUptime, int fflerp);
 
 /* Resets feed-forward clock from RTC */
-void ffclock_reset_clock(struct timespec *ts);
+void ffclock_setto_rtc(struct timespec *ts);
 
